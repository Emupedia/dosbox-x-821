576c576
< static const IO_ReadHandler* dosbox_integration_cb_ports_r[4] = {
---
> static  IO_ReadHandler* dosbox_integration_cb_ports_r[4] = {
587c587
< static const IO_WriteHandler* dosbox_integration_cb_ports_w[4] = {
---
> static  IO_WriteHandler* dosbox_integration_cb_ports_w[4] = {
656,1131d655
< ISAPnPDevice::ISAPnPDevice() {
< 	CSN = 0;
< 	logical_device = 0;
< 	memset(ident,0,sizeof(ident));
< 	ident_bp = 0;
< 	ident_2nd = 0;
< 	resource_data_len = 0;
< 	resource_data_pos = 0;
<     resource_data = NULL;
<     resource_ident = 0;
< 	alloc_res = NULL;
< 	alloc_write = 0;
< 	alloc_sz = 0;
< }
< 
< bool ISAPnPDevice::alloc(size_t sz) {
< 	if (sz == alloc_sz)
< 		return true;
< 
< 	if (alloc_res == resource_data) {
< 		resource_data_len = 0;
< 		resource_data_pos = 0;
< 		resource_data = NULL;
< 	}
< 	if (alloc_res != NULL)
< 		delete[] alloc_res;
< 
< 	alloc_res = NULL;
< 	alloc_write = 0;
< 	alloc_sz = 0;
< 
< 	if (sz == 0)
< 		return true;
< 	if (sz > 65536)
< 		return false;
< 
< 	alloc_res = new unsigned char[sz];
< 	if (alloc_res == NULL) return false;
< 	memset(alloc_res,0xFF,sz);
< 	alloc_sz = sz;
< 	return true;
< }
< 
< ISAPnPDevice::~ISAPnPDevice() {
< 	alloc(0);
< }
< 
< void ISAPnPDevice::begin_write_res() {
< 	if (alloc_res == NULL) return;
< 
< 	resource_data_pos = 0;
< 	resource_data_len = 0;
< 	resource_data = NULL;
< 	alloc_write = 0;
< }
< 
< void ISAPnPDevice::write_byte(const unsigned char c) {
< 	if (alloc_res == NULL || alloc_write >= alloc_sz) return;
< 	alloc_res[alloc_write++] = c;
< }
< 
< void ISAPnPDevice::write_begin_SMALLTAG(const ISAPnPDevice::SmallTags stag,unsigned char len) {
< 	if (len >= 8 || (unsigned int)stag >= 0x10) return;
< 	write_byte(((unsigned char)stag << 3) + len);
< }
< 
< void ISAPnPDevice::write_begin_LARGETAG(const ISAPnPDevice::LargeTags stag,unsigned int len) {
< 	if (len >= 4096) return;
< 	write_byte(0x80 + ((unsigned char)stag));
< 	write_byte(len & 0xFF);
< 	write_byte(len >> 8);
< }
< 
< void ISAPnPDevice::write_Device_ID(const char c1,const char c2,const char c3,const char c4,const char c5,const char c6,const char c7) {
< 	write_byte((((unsigned char)c1 & 0x1FU) << 2) + (((unsigned char)c2 & 0x18U) >> 3));
< 	write_byte((((unsigned char)c2 & 0x07U) << 5) + (((unsigned char)c3 & 0x1FU)     ));
< 	write_byte((((unsigned char)c4 & 0x0FU) << 4) + (((unsigned char)c5 & 0x0FU)     ));
< 	write_byte((((unsigned char)c6 & 0x0FU) << 4) + (((unsigned char)c7 & 0x0FU)     ));
< }
< 
< void ISAPnPDevice::write_Logical_Device_ID(const char c1,const char c2,const char c3,const char c4,const char c5,const char c6,const char c7) {
< 	write_begin_SMALLTAG(SmallTags::LogicalDeviceID,5);
< 	write_Device_ID(c1,c2,c3,c4,c5,c6,c7);
< 	write_byte(0x00);
< }
< 
< void ISAPnPDevice::write_Compatible_Device_ID(const char c1,const char c2,const char c3,const char c4,const char c5,const char c6,const char c7) {
< 	write_begin_SMALLTAG(SmallTags::CompatibleDeviceID,4);
< 	write_Device_ID(c1,c2,c3,c4,c5,c6,c7);
< }
< 
< void ISAPnPDevice::write_IRQ_Format(const uint16_t IRQ_mask,const unsigned char IRQ_signal_type) {
< 	bool write_irq_info = (IRQ_signal_type != 0);
< 
< 	write_begin_SMALLTAG(SmallTags::IRQFormat,write_irq_info?3:2);
< 	write_byte(IRQ_mask & 0xFF);
< 	write_byte(IRQ_mask >> 8);
< 	if (write_irq_info) write_byte(((unsigned char)IRQ_signal_type & 0x0F));
< }
< 
< void ISAPnPDevice::write_DMA_Format(const uint8_t DMA_mask,const unsigned char transfer_type_preference,const bool is_bus_master,const bool byte_mode,const bool word_mode,const unsigned char speed_supported) {
< 	write_begin_SMALLTAG(SmallTags::DMAFormat,2);
< 	write_byte(DMA_mask);
< 	write_byte(
< 		(transfer_type_preference & 0x03) |
< 		(is_bus_master ? 0x04 : 0x00) |
< 		(byte_mode ? 0x08 : 0x00) |
< 		(word_mode ? 0x10 : 0x00) |
< 		((speed_supported & 3) << 5));
< }
< 
< void ISAPnPDevice::write_IO_Port(const uint16_t min_port,const uint16_t max_port,const uint8_t count,const uint8_t alignment,const bool full16bitdecode) {
< 	write_begin_SMALLTAG(SmallTags::IOPortDescriptor,7);
< 	write_byte((full16bitdecode ? 0x01 : 0x00));
< 	write_byte(min_port & 0xFF);
< 	write_byte(min_port >> 8);
< 	write_byte(max_port & 0xFF);
< 	write_byte(max_port >> 8);
< 	write_byte(alignment);
< 	write_byte(count);
< }
< 
< void ISAPnPDevice::write_Dependent_Function_Start(const ISAPnPDevice::DependentFunctionConfig cfg,const bool force) {
< 	bool write_cfg_byte = force || (cfg != ISAPnPDevice::DependentFunctionConfig::AcceptableDependentConfiguration);
< 
< 	write_begin_SMALLTAG(SmallTags::StartDependentFunctions,write_cfg_byte ? 1 : 0);
< 	if (write_cfg_byte) write_byte((unsigned char)cfg);
< }
< 
< void ISAPnPDevice::write_End_Dependent_Functions() {
< 	write_begin_SMALLTAG(SmallTags::EndDependentFunctions,0);
< }
< 
< void ISAPnPDevice::write_nstring(const char *str,const size_t l) {
< 	if (alloc_res == NULL || alloc_write >= alloc_sz) return;
< 
< 	while (*str != 0 && alloc_write < alloc_sz)
< 		alloc_res[alloc_write++] = *str++;
< }
< 
< void ISAPnPDevice::write_Identifier_String(const char *str) {
< 	const size_t l = strlen(str);
< 	if (l > 4096) return;
< 
< 	write_begin_LARGETAG(LargeTags::IdentifierStringANSI,l);
< 	if (l != 0) write_nstring(str,l);
< }
< 
< void ISAPnPDevice::write_ISAPnP_version(unsigned char major,unsigned char minor,unsigned char vendor) {
< 	write_begin_SMALLTAG(SmallTags::PlugAndPlayVersionNumber,2);
< 	write_byte((major << 4) + minor);
< 	write_byte(vendor);
< }
< 
< void ISAPnPDevice::write_END() {
< 	unsigned char sum = 0;
< 	size_t i;
< 
< 	write_begin_SMALLTAG(SmallTags::EndTag,/*length*/1);
< 
< 	for (i=0;i < alloc_write;i++) sum += alloc_res[i];
< 	write_byte((0x100 - sum) & 0xFF);
< }
< 
< void ISAPnPDevice::end_write_res() {
< 	if (alloc_res == NULL) return;
< 
< 	write_END();
< 
< 	if (alloc_write >= alloc_sz) LOG(LOG_MISC,LOG_WARN)("ISA PNP generation overflow");
< 
< 	resource_data_pos = 0;
< 	resource_data_len = alloc_sz; // the device usually has a reason for allocating the fixed size it does
< 	resource_data = alloc_res;
< 	alloc_write = 0;
< }
< 
< void ISAPnPDevice::config(Bitu val) {
< }
< 
< void ISAPnPDevice::wakecsn(Bitu val) {
< 	ident_bp = 0;
< 	ident_2nd = 0;
< 	resource_data_pos = 0;
< 	resource_ident = 0;
< }
< 
< void ISAPnPDevice::select_logical_device(Bitu val) {
< }
< 	
< void ISAPnPDevice::checksum_ident() {
< 	unsigned char checksum = 0x6a,bit;
< 	int i,j;
< 
< 	for (i=0;i < 8;i++) {
< 		for (j=0;j < 8;j++) {
< 			bit = (ident[i] >> j) & 1;
< 			checksum = ((((checksum ^ (checksum >> 1)) & 1) ^ bit) << 7) | (checksum >> 1);
< 		}
< 	}
< 
< 	ident[8] = checksum;
< }
< 
< void ISAPnPDevice::on_pnp_key() {
< 	resource_ident = 0;
< }
< 
< uint8_t ISAPnPDevice::read(Bitu addr) {
< 	return 0x00;
< }
< 
< void ISAPnPDevice::write(Bitu addr,Bitu val) {
< }
< 
< #define MAX_ISA_PNP_DEVICES		64
< #define MAX_ISA_PNP_SYSDEVNODES		256
< 
< static ISAPnPDevice *ISA_PNP_selected = NULL;
< static ISAPnPDevice *ISA_PNP_devs[MAX_ISA_PNP_DEVICES] = {NULL}; /* FIXME: free objects on shutdown */
< static Bitu ISA_PNP_devnext = 0;
< 
< static const unsigned char ISAPnPIntegrationDevice_sysdev[] = {
< 	ISAPNP_IO_RANGE(
< 			0x01,					/* decodes 16-bit ISA addr */
< 			0x28,0x28,				/* min-max range I/O port */
< 			0x04,0x04),				/* align=4 length=4 */
< 	ISAPNP_END
< };
< 
< class ISAPnPIntegrationDevice : public ISAPnPDevice {
< 	public:
< 		ISAPnPIntegrationDevice() : ISAPnPDevice() {
< 			resource_ident = 0;
< 			resource_data = (unsigned char*)ISAPnPIntegrationDevice_sysdev;
< 			resource_data_len = sizeof(ISAPnPIntegrationDevice_sysdev);
< 			host_writed(ident+0,ISAPNP_ID('D','O','S',0x1,0x2,0x3,0x4)); /* DOS1234 test device */
< 			host_writed(ident+4,0xFFFFFFFFUL);
< 			checksum_ident();
< 		}
< };
< 
< ISAPnPIntegrationDevice *isapnpigdevice = NULL;
< 
< class ISAPNP_SysDevNode {
< public:
< 	ISAPNP_SysDevNode(const unsigned char *ir,int len,bool already_alloc=false) {
< 		if (already_alloc) {
< 			raw = (unsigned char*)ir;
< 			raw_len = len;
< 			own = false;
< 		}
< 		else {
< 			if (len > 65535) E_Exit("ISAPNP_SysDevNode data too long");
< 			raw = new unsigned char[len+1];
< 			if (ir == NULL) E_Exit("ISAPNP_SysDevNode cannot allocate buffer");
< 			memcpy(raw,ir,len);
< 			raw_len = len;
< 			raw[len] = 0;
< 			own = true;
< 		}
< 	}
< 	virtual ~ISAPNP_SysDevNode() {
< 		if (own) delete[] raw;
< 	}
< public:
< 	unsigned char*		raw;
< 	int			raw_len;
< 	bool			own;
< };
< 
< static ISAPNP_SysDevNode*	ISAPNP_SysDevNodes[MAX_ISA_PNP_SYSDEVNODES] = {NULL};
< static Bitu			ISAPNP_SysDevNodeLargest=0;
< static Bitu			ISAPNP_SysDevNodeCount=0;
< 
< void ISA_PNP_FreeAllSysNodeDevs() {
< 	Bitu i;
< 
< 	for (i=0;i < MAX_ISA_PNP_SYSDEVNODES;i++) {
< 		if (ISAPNP_SysDevNodes[i] != NULL) delete ISAPNP_SysDevNodes[i];
< 		ISAPNP_SysDevNodes[i] = NULL;
< 	}
< 
< 	ISAPNP_SysDevNodeLargest=0;
< 	ISAPNP_SysDevNodeCount=0;
< }
< 
< void ISA_PNP_FreeAllDevs() {
< 	Bitu i;
< 
< 	for (i=0;i < MAX_ISA_PNP_DEVICES;i++) {
< 		if (ISA_PNP_devs[i] != NULL) {
< 			delete ISA_PNP_devs[i];
< 			ISA_PNP_devs[i] = NULL;
< 		}
< 	}
< 	for (i=0;i < MAX_ISA_PNP_SYSDEVNODES;i++) {
< 		if (ISAPNP_SysDevNodes[i] != NULL) delete ISAPNP_SysDevNodes[i];
< 		ISAPNP_SysDevNodes[i] = NULL;
< 	}
< 
< 	ISAPNP_SysDevNodeLargest=0;
< 	ISAPNP_SysDevNodeCount=0;
< }
< 
< void ISA_PNP_devreg(ISAPnPDevice *x) {
< 	if (ISA_PNP_devnext < MAX_ISA_PNP_DEVICES) {
< 		if (ISA_PNP_WPORT_BIOS == 0) ISA_PNP_WPORT_BIOS = ISA_PNP_WPORT;
< 		ISA_PNP_devs[ISA_PNP_devnext++] = x;
< 		x->CSN = ISA_PNP_devnext;
< 	}
< }
< 
< static Bitu isapnp_read_port(Bitu port,Bitu /*iolen*/) {
< 	Bitu ret=0xff;
< 
< 	switch (ISA_PNP_CUR_ADDR) {
< 		case 0x01:	/* serial isolation */
< 			   if (ISA_PNP_selected && ISA_PNP_selected->CSN == 0) {
< 				   if (ISA_PNP_selected->ident_bp < 72) {
< 					   if (ISA_PNP_selected->ident[ISA_PNP_selected->ident_bp>>3] & (1 << (ISA_PNP_selected->ident_bp&7)))
< 						   ret = ISA_PNP_selected->ident_2nd ? 0xAA : 0x55;
< 					   else
< 						   ret = 0xFF;
< 
< 					   if (++ISA_PNP_selected->ident_2nd >= 2) {
< 						   ISA_PNP_selected->ident_2nd = 0;
< 						   ISA_PNP_selected->ident_bp++;
< 					   }
< 				   }
< 			   }
< 			   else {
< 				   ret = 0xFF;
< 			   }
< 			   break;
< 		case 0x04:	/* read resource data */
< 			   if (ISA_PNP_selected) {
< 				   if (ISA_PNP_selected->resource_ident < 9)
< 					   ret = ISA_PNP_selected->ident[ISA_PNP_selected->resource_ident++];			   
< 				   else {
< 					   /* real-world hardware testing shows that devices act as if there was some fixed block of ROM,
< 					    * that repeats every 128, 256, 512, or 1024 bytes if you just blindly read from this port. */
< 					   if (ISA_PNP_selected->resource_data_pos < ISA_PNP_selected->resource_data_len)
< 						   ret = ISA_PNP_selected->resource_data[ISA_PNP_selected->resource_data_pos++];
< 
< 					   /* that means that if you read enough bytes the ROM loops back to returning the ident */
< 					   if (ISA_PNP_selected->resource_data_pos >= ISA_PNP_selected->resource_data_len) {
< 						   ISA_PNP_selected->resource_data_pos = 0;
< 						   ISA_PNP_selected->resource_ident = 0;
< 					   }
< 				   }
< 			   }
< 			   break;
< 		case 0x05:	/* read resource status */
< 			   if (ISA_PNP_selected) {
< 				   /* real-world hardware testing shows that devices act as if there was some fixed block of ROM,
< 				    * that repeats every 128, 256, 512, or 1024 bytes if you just blindly read from this port.
< 				    * therefore, there's always a byte to return. */
< 				   ret = 0x01;	/* TODO: simulate hardware slowness */
< 			   }
< 			   break;
< 		case 0x06:	/* card select number */
< 			   if (ISA_PNP_selected) ret = ISA_PNP_selected->CSN;
< 			   break;
< 		case 0x07:	/* logical device number */
< 			   if (ISA_PNP_selected) ret = ISA_PNP_selected->logical_device;
< 			   break;
< 		default:	/* pass the rest down to the class */
< 			   if (ISA_PNP_selected) ret = ISA_PNP_selected->read(ISA_PNP_CUR_ADDR);
< 			   break;
< 	}
< 
< //	if (1) LOG_MSG("PnP read(%02X) = %02X\n",ISA_PNP_CUR_ADDR,ret);
< 	return ret;
< }
< 
< void isapnp_write_port(Bitu port,Bitu val,Bitu /*iolen*/) {
< 	Bitu i;
< 
< 	if (port == 0x279) {
< //		if (1) LOG_MSG("PnP addr(%02X)\n",val);
< 		if (val == isa_pnp_init_keystring[ISA_PNP_KEYMATCH]) {
< 			if (++ISA_PNP_KEYMATCH == 32) {
< //				LOG_MSG("ISA PnP key -> going to sleep\n");
< 				ISA_PNP_CUR_STATE = ISA_PNP_SLEEP;
< 				ISA_PNP_KEYMATCH = 0;
< 				for (i=0;i < MAX_ISA_PNP_DEVICES;i++) {
< 					if (ISA_PNP_devs[i] != NULL) {
< 						ISA_PNP_devs[i]->on_pnp_key();
< 					}
< 				}
< 			}
< 		}
< 		else {
< 			ISA_PNP_KEYMATCH = 0;
< 		}
< 
< 		ISA_PNP_CUR_ADDR = val;
< 	}
< 	else if (port == 0xA79) {
< //		if (1) LOG_MSG("PnP write(%02X) = %02X\n",ISA_PNP_CUR_ADDR,val);
< 		switch (ISA_PNP_CUR_ADDR) {
< 			case 0x00: {	/* RD_DATA */
< 				unsigned int np = ((val & 0xFF) << 2) | 3;
< 				if (np != ISA_PNP_WPORT) {
< 					if (ISAPNP_PNP_READ_PORT != NULL) {
< 						ISAPNP_PNP_READ_PORT = NULL;
< 						delete ISAPNP_PNP_READ_PORT;
< 					}
< 
< 					if (np >= 0x200 && np <= 0x3FF) { /* allowable port I/O range according to spec */
< 						LOG_MSG("PNP OS changed I/O read port to 0x%03X (from 0x%03X)\n",np,ISA_PNP_WPORT);
< 
< 						ISA_PNP_WPORT = np;
< 						ISAPNP_PNP_READ_PORT = new IO_ReadHandleObject;
< 						ISAPNP_PNP_READ_PORT->Install(ISA_PNP_WPORT,isapnp_read_port,IO_MB);
< 					}
< 					else {
< 						LOG_MSG("PNP OS I/O read port disabled\n");
< 
< 						ISA_PNP_WPORT = 0;
< 					}
< 
< 					if (ISA_PNP_selected != NULL) {
< 						ISA_PNP_selected->ident_bp = 0;
< 						ISA_PNP_selected->ident_2nd = 0;
< 						ISA_PNP_selected->resource_data_pos = 0;
< 					}
< 				}
< 			} break;
< 			case 0x02:	/* config control */
< 				   if (val & 4) {
< 					   /* ALL CARDS RESET CSN to 0 */
< 					   for (i=0;i < MAX_ISA_PNP_DEVICES;i++) {
< 						   if (ISA_PNP_devs[i] != NULL) {
< 							   ISA_PNP_devs[i]->CSN = 0;
< 						   }
< 					   }
< 				   }
< 				   if (val & 2) ISA_PNP_CUR_STATE = ISA_PNP_WAIT_FOR_KEY;
< 				   if ((val & 1) && ISA_PNP_selected) ISA_PNP_selected->config(val);
< 				   for (i=0;i < MAX_ISA_PNP_DEVICES;i++) {
< 					   if (ISA_PNP_devs[i] != NULL) {
< 						   ISA_PNP_devs[i]->ident_bp = 0;
< 						   ISA_PNP_devs[i]->ident_2nd = 0;
< 						   ISA_PNP_devs[i]->resource_data_pos = 0;
< 					   }
< 				   }
< 				   break;
< 			case 0x03: {	/* wake[CSN] */
< 				ISA_PNP_selected = NULL;
< 				for (i=0;ISA_PNP_selected == NULL && i < MAX_ISA_PNP_DEVICES;i++) {
< 					if (ISA_PNP_devs[i] == NULL)
< 						continue;
< 					if (ISA_PNP_devs[i]->CSN == val) {
< 						ISA_PNP_selected = ISA_PNP_devs[i];
< 						ISA_PNP_selected->wakecsn(val);
< 					}
< 				}
< 				if (val == 0)
< 					ISA_PNP_CUR_STATE = ISA_PNP_ISOLATE;
< 				else
< 					ISA_PNP_CUR_STATE = ISA_PNP_CONFIG;
< 				} break;
< 			case 0x06:	/* card select number */
< 				if (ISA_PNP_selected) ISA_PNP_selected->CSN = val;
< 				break;
< 			case 0x07:	/* logical device number */
< 				if (ISA_PNP_selected) ISA_PNP_selected->select_logical_device(val);
< 				break;
< 			default:	/* pass the rest down to the class */
< 				if (ISA_PNP_selected) ISA_PNP_selected->write(ISA_PNP_CUR_ADDR,val);
< 				break;
< 		}
< 	}
< }
1138,1638d661
< void ISAPNP_Cfg_Reset(Section *sec) {
< 	Section_prop * section=static_cast<Section_prop *>(control->GetSection("cpu"));
< 
< 	LOG(LOG_MISC,LOG_DEBUG)("Initializing ISA PnP emulation");
< 
< 	enable_integration_device = section->Get_bool("integration device");
<     enable_integration_device_pnp = section->Get_bool("integration device pnp");
< 	ISAPNPBIOS = section->Get_bool("isapnpbios");
< 	APMBIOS = section->Get_bool("apmbios");
< 	APMBIOS_pnp = section->Get_bool("apmbios pnp");
< 	APMBIOS_allow_realmode = section->Get_bool("apmbios allow realmode");
< 	APMBIOS_allow_prot16 = section->Get_bool("apmbios allow 16-bit protected mode");
< 	APMBIOS_allow_prot32 = section->Get_bool("apmbios allow 32-bit protected mode");
< 
< 	std::string apmbiosver = section->Get_string("apmbios version");
< 
< 	if (apmbiosver == "1.0")
< 		APM_BIOS_minor_version = 0;
< 	else if (apmbiosver == "1.1")
< 		APM_BIOS_minor_version = 1;
< 	else if (apmbiosver == "1.2")
< 		APM_BIOS_minor_version = 2;
< 	else//auto
< 		APM_BIOS_minor_version = 2;
< 
<     /* PC-98 does not have APM.
<      * I *think* it has Plug & Play, but probably different from ISA PnP and specific to the C-Bus interface,
<      * which I have no information on at this time --J.C. */
<     if (IS_PC98_ARCH)
<         return;
< 
< 	LOG(LOG_MISC,LOG_DEBUG)("APM BIOS allow: real=%u pm16=%u pm32=%u version=1.%u",
< 		APMBIOS_allow_realmode,
< 		APMBIOS_allow_prot16,
< 		APMBIOS_allow_prot32,
< 		APM_BIOS_minor_version);
< 
< 	if (APMBIOS && (APMBIOS_allow_prot16 || APMBIOS_allow_prot32) && INT15_apm_pmentry == 0) {
< 		Bitu cb,base;
< 
< 		/* NTS: This is... kind of a terrible hack. It basically tricks Windows into executing our
< 		 *      INT 15h handler as if the APM entry point. Except that instead of an actual INT 15h
< 		 *      triggering the callback, a FAR CALL triggers the callback instead (CB_RETF not CB_IRET). */
< 		/* TODO: We should really consider moving the APM BIOS code in INT15_Handler() out into it's
< 		 *       own function, then having the INT15_Handler() call it as well as directing this callback
< 		 *       directly to it. If you think about it, this hack also lets the "APM entry point" invoke
< 		 *       other arbitrary INT 15h calls which is not valid. */
< 
< 		cb = CALLBACK_Allocate();
< 		INT15_apm_pmentry = CALLBACK_RealPointer(cb);
< 		LOG_MSG("Allocated APM BIOS pm entry point at %04x:%04x\n",INT15_apm_pmentry>>16,INT15_apm_pmentry&0xFFFF);
< 		CALLBACK_Setup(cb,INT15_Handler,CB_RETF,"APM BIOS protected mode entry point");
< 
<         /* NTS: Actually INT15_Handler is written to act like an interrupt (IRETF) type callback.
<          *      Prior versions hacked this into something that responds by CB_RETF, however some
<          *      poking around reveals that CALLBACK_SCF and friends still assume an interrupt
<          *      stack, thus, the cause of random crashes in Windows was simply that we were
<          *      flipping flag bits in the middle of the return address on the stack. The other
<          *      source of random crashes is that the CF/ZF manipulation in INT 15h wasn't making
<          *      it's way back to Windows, meaning that when APM BIOS emulation intended to return
<          *      an error (by setting CF), Windows didn't get the memo (CF wasn't set on return)
<          *      and acted as if the call succeeded, or worse, CF happened to be set on entry and
<          *      was never cleared by APM BIOS emulation.
<          *
<          *      So what we need is:
<          *
<          *      PUSHF           ; put flags in right place
<          *      PUSH    BP      ; dummy FAR pointer
<          *      PUSH    BP      ; again
<          *      <callback>
<          *      POP     BP      ; drop it
<          *      POP     BP      ; drop it
<          *      POPF
<          *      RETF
<          *
<          *      Then CALLBACK_SCF can work normally this way.
<          *
<          * NTS: We *still* need to separate APM BIOS calls from the general INT 15H emulation though... */
<         base = Real2Phys(INT15_apm_pmentry);
<         LOG_MSG("Writing code to %05x\n",(unsigned int)base);
< 
<         phys_writeb(base+0x00,0x9C);                             /* pushf */
<         phys_writeb(base+0x01,0x55);                             /* push (e)bp */
<         phys_writeb(base+0x02,0x55);                             /* push (e)bp */
< 
<         phys_writeb(base+0x03,(Bit8u)0xFE);						//GRP 4
<         phys_writeb(base+0x04,(Bit8u)0x38);						//Extra Callback instruction
<         phys_writew(base+0x05,(Bit16u)cb);               		//The immediate word
< 
<         phys_writeb(base+0x07,0x5D);                             /* pop (e)bp */
<         phys_writeb(base+0x08,0x5D);                             /* pop (e)bp */
<         phys_writeb(base+0x09,0x9D);                             /* popf */
<         phys_writeb(base+0x0A,0xCB);                             /* retf */
<     }
< }
< 
< void ISAPNP_Cfg_Init() {
< 	AddVMEventFunction(VM_EVENT_RESET,AddVMEventFunctionFuncPair(ISAPNP_Cfg_Reset));
< }
< 
< /* the PnP callback registered two entry points. One for real, one for protected mode. */
< static Bitu PNPentry_real,PNPentry_prot;
< 
< static bool ISAPNP_Verify_BiosSelector(Bitu seg) {
< 	if (!cpu.pmode || (reg_flags & FLAG_VM)) {
< 		return (seg == 0xF000);
< 	} else if (seg == 0)
< 		return 0;
< 	else {
< #if 1
< 		/* FIXME: Always return true. But figure out how to ask DOSBox the linear->phys
< 			  mapping to determine whether the segment's base address maps to 0xF0000.
< 			  In the meantime disabling this check makes PnP BIOS emulation work with
< 			  Windows 95 OSR2 which appears to give us a segment mapped to a virtual
< 			  address rather than linearly mapped to 0xF0000 as Windows 95 original
< 			  did. */
< 		return true;
< #else
< 		Descriptor desc;
< 		cpu.gdt.GetDescriptor(seg,desc);
< 
< 		/* TODO: Check desc.Type() to make sure it's a writeable data segment */
< 		return (desc.GetBase() == 0xF0000);
< #endif
< 	}
< }
< 
< static bool ISAPNP_CPU_ProtMode() {
< 	if (!cpu.pmode || (reg_flags & FLAG_VM))
< 		return 0;
< 
< 	return 1;
< }
< 
< static Bitu ISAPNP_xlate_address(Bitu far_ptr) {
< 	if (!cpu.pmode || (reg_flags & FLAG_VM))
< 		return Real2Phys(far_ptr);
< 	else {
< 		Descriptor desc;
< 		cpu.gdt.GetDescriptor(far_ptr >> 16,desc);
< 
< 		/* TODO: Check desc.Type() to make sure it's a writeable data segment */
< 		return (desc.GetBase() + (far_ptr & 0xFFFF));
< 	}
< }
< 
< static const unsigned char ISAPNP_sysdev_Keyboard[] = {
< 	ISAPNP_SYSDEV_HEADER(
< 			ISAPNP_ID('P','N','P',0x0,0x3,0x0,0x3), /* PNP0303 IBM Enhanced 101/102 key with PS/2 */
< 			ISAPNP_TYPE(0x09,0x00,0x00),		/* type: input, keyboard */
< 			0x0001 | 0x0002),			/* can't disable, can't configure */
< 	/*----------allocated--------*/
< 	ISAPNP_IO_RANGE(
< 			0x01,					/* decodes 16-bit ISA addr */
< 			0x60,0x60,				/* min-max range I/O port */
< 			0x01,0x01),				/* align=1 length=1 */
< 	ISAPNP_IO_RANGE(
< 			0x01,					/* decodes 16-bit ISA addr */
< 			0x64,0x64,				/* min-max range I/O port */
< 			0x01,0x01),				/* align=1 length=1 */
< 	ISAPNP_IRQ_SINGLE(
< 			1,					/* IRQ 1 */
< 			0x09),					/* HTE=1 LTL=1 */
< 	ISAPNP_END,
< 	/*----------possible--------*/
< 	ISAPNP_END,
< 	/*----------compatible--------*/
< 	ISAPNP_END
< };
< 
< static const unsigned char ISAPNP_sysdev_Mouse[] = {
< 	ISAPNP_SYSDEV_HEADER(
< 			ISAPNP_ID('P','N','P',0x0,0xF,0x0,0xE), /* PNP0F0E Microsoft compatible PS/2 */
< 			ISAPNP_TYPE(0x09,0x02,0x00),		/* type: input, keyboard */
< 			0x0001 | 0x0002),			/* can't disable, can't configure */
< 	/*----------allocated--------*/
< 	ISAPNP_IRQ_SINGLE(
< 			12,					/* IRQ 12 */
< 			0x09),					/* HTE=1 LTL=1 */
< 	ISAPNP_END,
< 	/*----------possible--------*/
< 	ISAPNP_END,
< 	/*----------compatible--------*/
< 	ISAPNP_END
< };
< 
< static const unsigned char ISAPNP_sysdev_DMA_Controller[] = {
< 	ISAPNP_SYSDEV_HEADER(
< 			ISAPNP_ID('P','N','P',0x0,0x2,0x0,0x0), /* PNP0200 AT DMA controller */
< 			ISAPNP_TYPE(0x08,0x01,0x00),		/* type: input, keyboard */
< 			0x0001 | 0x0002),			/* can't disable, can't configure */
< 	/*----------allocated--------*/
< 	ISAPNP_IO_RANGE(
< 			0x01,					/* decodes 16-bit ISA addr */
< 			0x00,0x00,				/* min-max range I/O port (DMA channels 0-3) */
< 			0x10,0x10),				/* align=16 length=16 */
< 	ISAPNP_IO_RANGE(
< 			0x01,					/* decodes 16-bit ISA addr */
< 			0x81,0x81,				/* min-max range I/O port (DMA page registers) */
< 			0x01,0x0F),				/* align=1 length=15 */
< 	ISAPNP_IO_RANGE(
< 			0x01,					/* decodes 16-bit ISA addr */
< 			0xC0,0xC0,				/* min-max range I/O port (AT DMA channels 4-7) */
< 			0x20,0x20),				/* align=32 length=32 */
< 	ISAPNP_DMA_SINGLE(
< 			4,					/* DMA 4 */
< 			0x01),					/* 8/16-bit transfers, compatible speed */
< 	ISAPNP_END,
< 	/*----------possible--------*/
< 	ISAPNP_END,
< 	/*----------compatible--------*/
< 	ISAPNP_END
< };
< 
< static const unsigned char ISAPNP_sysdev_PIC[] = {
< 	ISAPNP_SYSDEV_HEADER(
< 			ISAPNP_ID('P','N','P',0x0,0x0,0x0,0x0), /* PNP0000 Interrupt controller */
< 			ISAPNP_TYPE(0x08,0x00,0x01),		/* type: ISA interrupt controller */
< 			0x0001 | 0x0002),			/* can't disable, can't configure */
< 	/*----------allocated--------*/
< 	ISAPNP_IO_RANGE(
< 			0x01,					/* decodes 16-bit ISA addr */
< 			0x20,0x20,				/* min-max range I/O port */
< 			0x01,0x02),				/* align=1 length=2 */
< 	ISAPNP_IO_RANGE(
< 			0x01,					/* decodes 16-bit ISA addr */
< 			0xA0,0xA0,				/* min-max range I/O port */
< 			0x01,0x02),				/* align=1 length=2 */
< 	ISAPNP_IRQ_SINGLE(
< 			2,					/* IRQ 2 */
< 			0x09),					/* HTE=1 LTL=1 */
< 	ISAPNP_END,
< 	/*----------possible--------*/
< 	ISAPNP_END,
< 	/*----------compatible--------*/
< 	ISAPNP_END
< };
< 
< static const unsigned char ISAPNP_sysdev_Timer[] = {
< 	ISAPNP_SYSDEV_HEADER(
< 			ISAPNP_ID('P','N','P',0x0,0x1,0x0,0x0), /* PNP0100 Timer */
< 			ISAPNP_TYPE(0x08,0x02,0x01),		/* type: ISA timer */
< 			0x0001 | 0x0002),			/* can't disable, can't configure */
< 	/*----------allocated--------*/
< 	ISAPNP_IO_RANGE(
< 			0x01,					/* decodes 16-bit ISA addr */
< 			0x40,0x40,				/* min-max range I/O port */
< 			0x04,0x04),				/* align=4 length=4 */
< 	ISAPNP_IRQ_SINGLE(
< 			0,					/* IRQ 0 */
< 			0x09),					/* HTE=1 LTL=1 */
< 	ISAPNP_END,
< 	/*----------possible--------*/
< 	ISAPNP_END,
< 	/*----------compatible--------*/
< 	ISAPNP_END
< };
< 
< static const unsigned char ISAPNP_sysdev_RTC[] = {
< 	ISAPNP_SYSDEV_HEADER(
< 			ISAPNP_ID('P','N','P',0x0,0xB,0x0,0x0), /* PNP0B00 Real-time clock */
< 			ISAPNP_TYPE(0x08,0x03,0x01),		/* type: ISA real-time clock */
< 			0x0001 | 0x0002),			/* can't disable, can't configure */
< 	/*----------allocated--------*/
< 	ISAPNP_IO_RANGE(
< 			0x01,					/* decodes 16-bit ISA addr */
< 			0x70,0x70,				/* min-max range I/O port */
< 			0x01,0x02),				/* align=1 length=2 */
< 	ISAPNP_IRQ_SINGLE(
< 			8,					/* IRQ 8 */
< 			0x09),					/* HTE=1 LTL=1 */
< 	ISAPNP_END,
< 	/*----------possible--------*/
< 	ISAPNP_END,
< 	/*----------compatible--------*/
< 	ISAPNP_END
< };
< 
< static const unsigned char ISAPNP_sysdev_PC_Speaker[] = {
< 	ISAPNP_SYSDEV_HEADER(
< 			ISAPNP_ID('P','N','P',0x0,0x8,0x0,0x0), /* PNP0800 PC speaker */
< 			ISAPNP_TYPE(0x04,0x01,0x00),		/* type: PC speaker */
< 			0x0001 | 0x0002),			/* can't disable, can't configure */
< 	/*----------allocated--------*/
< 	ISAPNP_IO_RANGE(
< 			0x01,					/* decodes 16-bit ISA addr */
< 			0x61,0x61,				/* min-max range I/O port */
< 			0x01,0x01),				/* align=1 length=1 */
< 	ISAPNP_END,
< 	/*----------possible--------*/
< 	ISAPNP_END,
< 	/*----------compatible--------*/
< 	ISAPNP_END
< };
< 
< static const unsigned char ISAPNP_sysdev_Numeric_Coprocessor[] = {
< 	ISAPNP_SYSDEV_HEADER(
< 			ISAPNP_ID('P','N','P',0x0,0xC,0x0,0x4), /* PNP0C04 Numeric Coprocessor */
< 			ISAPNP_TYPE(0x0B,0x80,0x00),		/* type: FPU */
< 			0x0001 | 0x0002),			/* can't disable, can't configure */
< 	/*----------allocated--------*/
< 	ISAPNP_IO_RANGE(
< 			0x01,					/* decodes 16-bit ISA addr */
< 			0xF0,0xF0,				/* min-max range I/O port */
< 			0x10,0x10),				/* align=16 length=16 */
< 	ISAPNP_IRQ_SINGLE(
< 			13,					/* IRQ 13 */
< 			0x09),					/* HTE=1 LTL=1 */
< 	ISAPNP_END,
< 	/*----------possible--------*/
< 	ISAPNP_END,
< 	/*----------compatible--------*/
< 	ISAPNP_END
< };
< 
< static const unsigned char ISAPNP_sysdev_System_Board[] = {
< 	ISAPNP_SYSDEV_HEADER(
< 			ISAPNP_ID('P','N','P',0x0,0xC,0x0,0x1), /* PNP0C01 System board */
< 			ISAPNP_TYPE(0x08,0x80,0x00),		/* type: System peripheral, Other */
< 			0x0001 | 0x0002),			/* can't disable, can't configure */
< 	/*----------allocated--------*/
< 	ISAPNP_IO_RANGE(
< 			0x01,					/* decodes 16-bit ISA addr */
< 			0x24,0x24,				/* min-max range I/O port */
< 			0x04,0x04),				/* align=4 length=4 */
< 	ISAPNP_END,
< 	/*----------possible--------*/
< 	ISAPNP_END,
< 	/*----------compatible--------*/
< 	ISAPNP_END
< };
< 
< /* NTS: If some of my late 1990's laptops are any indication, this resource list can be used
<  *      as a hint that the motherboard supports Intel EISA/PCI controller DMA registers that
<  *      allow ISA DMA to extend to 32-bit addresses instead of being limited to 24-bit */
< static const unsigned char ISAPNP_sysdev_General_ISAPNP[] = {
< 	ISAPNP_SYSDEV_HEADER(
< 			ISAPNP_ID('P','N','P',0x0,0xC,0x0,0x2), /* PNP0C02 General ID for reserving resources */
< 			ISAPNP_TYPE(0x08,0x80,0x00),		/* type: System peripheral, Other */
< 			0x0001 | 0x0002),			/* can't disable, can't configure */
< 	/*----------allocated--------*/
< 	ISAPNP_IO_RANGE(
< 			0x01,					/* decodes 16-bit ISA addr */
< 			0x208,0x208,				/* min-max range I/O port */
< 			0x04,0x04),				/* align=4 length=4 */
< 	ISAPNP_END,
< 	/*----------possible--------*/
< 	ISAPNP_END,
< 	/*----------compatible--------*/
< 	ISAPNP_END
< };
< 
< /* PnP system entry to tell Windows 95 the obvious: That there's an ISA bus present */
< /* NTS: Examination of some old laptops of mine shows that these devices do not list any resources,
<  *      or at least, an old Toshiba of mine lists the PCI registers 0xCF8-0xCFF as motherboard resources
<  *      and defines no resources for the PCI Bus PnP device. */
< static const unsigned char ISAPNP_sysdev_ISA_BUS[] = {
< 	ISAPNP_SYSDEV_HEADER(
< 			ISAPNP_ID('P','N','P',0x0,0xA,0x0,0x0), /* PNP0A00 ISA Bus */
< 			ISAPNP_TYPE(0x06,0x04,0x00),		/* type: System device, peripheral bus */
< 			0x0001 | 0x0002),			/* can't disable, can't configure */
< 	/*----------allocated--------*/
< 	ISAPNP_END,
< 	/*----------possible--------*/
< 	ISAPNP_END,
< 	/*----------compatible--------*/
< 	ISAPNP_END
< };
< 
< /* PnP system entry to tell Windows 95 the obvious: That there's a PCI bus present */
< static const unsigned char ISAPNP_sysdev_PCI_BUS[] = {
< 	ISAPNP_SYSDEV_HEADER(
< 			ISAPNP_ID('P','N','P',0x0,0xA,0x0,0x3), /* PNP0A03 PCI Bus */
< 			ISAPNP_TYPE(0x06,0x04,0x00),		/* type: System device, peripheral bus */
< 			0x0001 | 0x0002),			/* can't disable, can't configure */
< 	/*----------allocated--------*/
< 	ISAPNP_END,
< 	/*----------possible--------*/
< 	ISAPNP_END,
< 	/*----------compatible--------*/
< 	ISAPNP_END
< };
< 
< /* to help convince Windows 95 that the APM BIOS is present */
< static const unsigned char ISAPNP_sysdev_APM_BIOS[] = {
< 	ISAPNP_SYSDEV_HEADER(
< 			ISAPNP_ID('P','N','P',0x0,0xC,0x0,0x5), /* PNP0C05 APM BIOS */
< 			ISAPNP_TYPE(0x08,0x80,0x00),		/* type: FIXME is this right?? I can't find any examples or documentation */
< 			0x0001 | 0x0002),			/* can't disable, can't configure */
< 	/*----------allocated--------*/
< 	ISAPNP_END,
< 	/*----------possible--------*/
< 	ISAPNP_END,
< 	/*----------compatible--------*/
< 	ISAPNP_END
< };
< 
< bool ISAPNP_RegisterSysDev(const unsigned char *raw,Bitu len,bool already) {
< 	if (ISAPNP_SysDevNodeCount >= MAX_ISA_PNP_SYSDEVNODES)
< 		return false;
< 
< 	ISAPNP_SysDevNodes[ISAPNP_SysDevNodeCount] = new ISAPNP_SysDevNode(raw,len,already);
< 	if (ISAPNP_SysDevNodes[ISAPNP_SysDevNodeCount] == NULL)
< 		return false;
< 	
< 	ISAPNP_SysDevNodeCount++;
< 	if (ISAPNP_SysDevNodeLargest < (len+3))
< 		ISAPNP_SysDevNodeLargest = len+3;
< 
< 	return true;
< }
< 
< /* ISA PnP function calls have their parameters stored on the stack "C" __cdecl style. Parameters
<  * are either int, long, or FAR pointers. Like __cdecl an assembly language implementation pushes
<  * the function arguments on the stack BACKWARDS */
< static Bitu ISAPNP_Handler(bool protmode /* called from protected mode interface == true */) {
< 	Bitu arg;
< 	Bitu func,BiosSelector;
< 
< 	/* I like how the ISA PnP spec says that the 16-bit entry points (real and protected) are given 16-bit data segments
< 	 * which implies that all segments involved might as well be 16-bit.
< 	 *
< 	 * Right?
< 	 *
< 	 * Well, guess what Windows 95 gives us when calling this entry point:
< 	 *
< 	 *     Segment SS = DS = 0x30  base=0 limit=0xFFFFFFFF
< 	 *       SS:SP = 0x30:0xC138BADF or something like that from within BIOS.VXD
< 	 *
< 	 * Yeah... for a 16-bit code segment call. Right. Typical Microsoft. >:(
< 	 *
< 	 * This might also explain why my early experiments with Bochs always had the perpetual
< 	 * APM BIOS that never worked but was always detected.
< 	 *
< 	 * ------------------------------------------------------------------------
< 	 * Windows 95 OSR2:
< 	 *
< 	 * Windows 95 OSR2 however uses a 16-bit stack (where the stack segment is based somewhere
< 	 * around 0xC1xxxxxx), all we have to do to correctly access it is work through the page tables.
< 	 * This is within spec, but now Microsoft sends us a data segment that is based at virtual address
< 	 * 0xC2xxxxxx, which is why I had to disable the "verify selector" routine */
< 	arg = SegPhys(ss) + (reg_esp&cpu.stack.mask) + (2*2); /* entry point (real and protected) is 16-bit, expected to RETF (skip CS:IP) */
< 
< 	if (protmode != ISAPNP_CPU_ProtMode()) {
< 		//LOG_MSG("ISA PnP %s entry point called from %s. On real BIOSes this would CRASH\n",protmode ? "Protected mode" : "Real mode",
< 		//	ISAPNP_CPU_ProtMode() ? "Protected mode" : "Real mode");
< 		reg_ax = 0x84;/* BAD_PARAMETER */
< 		return 0;
< 	}
< 
< 	func = mem_readw(arg);
< //	LOG_MSG("PnP prot=%u DS=%04x (base=0x%08lx) SS:ESP=%04x:%04x (base=0x%08lx phys=0x%08lx) function=0x%04x\n",
< //		(unsigned int)protmode,(unsigned int)SegValue(ds),(unsigned long)SegPhys(ds),
< //		(unsigned int)SegValue(ss),(unsigned int)reg_esp,(unsigned long)SegPhys(ss),
< //		(unsigned long)arg,(unsigned int)func);
< 
< 	/* every function takes the form
< 	 *
< 	 * int __cdecl FAR (*entrypoint)(int Function...);
< 	 *
< 	 * so the first argument on the stack is an int that we read to determine what the caller is asking
< 	 *
< 	 * Dont forget in the real-mode world:
< 	 *    sizeof(int) == 16 bits
< 	 *    sizeof(long) == 32 bits
< 	 */    
< 	switch (func) {
< 		case 0: {		/* Get Number of System Nodes */
< 			/* int __cdecl FAR (*entrypoint)(int Function,unsigned char FAR *NumNodes,unsigned int FAR *NodeSize,unsigned int BiosSelector);
< 			 *                               ^ +0         ^ +2                        ^ +6                       ^ +10                       = 12 */
< 			Bitu NumNodes_ptr = mem_readd(arg+2);
< 			Bitu NodeSize_ptr = mem_readd(arg+6);
< 			BiosSelector = mem_readw(arg+10);
< 
< 			if (!ISAPNP_Verify_BiosSelector(BiosSelector))
< 				goto badBiosSelector;
< 
< 			if (NumNodes_ptr != 0) mem_writeb(ISAPNP_xlate_address(NumNodes_ptr),ISAPNP_SysDevNodeCount);
< 			if (NodeSize_ptr != 0) mem_writew(ISAPNP_xlate_address(NodeSize_ptr),ISAPNP_SysDevNodeLargest);
< 
< 			reg_ax = 0x00;/* SUCCESS */
< 		} break;
< 		case 1: {		/* Get System Device Node */
< 			/* int __cdecl FAR (*entrypoint)(int Function,unsigned char FAR *Node,struct DEV_NODE FAR *devNodeBuffer,unsigned int Control,unsigned int BiosSelector);
< 			 *                               ^ +0         ^ +2                    ^ +6                               ^ +10                ^ +12                       = 14 */
< 			Bitu Node_ptr = mem_readd(arg+2);
< 			Bitu devNodeBuffer_ptr = mem_readd(arg+6);
< 			Bitu Control = mem_readw(arg+10);
< 			BiosSelector = mem_readw(arg+12);
< 			unsigned char Node;
< 			Bitu i=0;
< 
< 			if (!ISAPNP_Verify_BiosSelector(BiosSelector))
< 				goto badBiosSelector;
< 
< 			/* control bits 0-1 must be '01' or '10' but not '00' or '11' */
< 			if (Control == 0 || (Control&3) == 3) {
< 				LOG_MSG("ISAPNP Get System Device Node: Invalid Control value 0x%04x\n",(int)Control);
< 				reg_ax = 0x84;/* BAD_PARAMETER */
< 				break;
< 			}
1640,1743d662
< 			devNodeBuffer_ptr = ISAPNP_xlate_address(devNodeBuffer_ptr);
< 			Node_ptr = ISAPNP_xlate_address(Node_ptr);
< 			Node = mem_readb(Node_ptr);
< 			if (Node >= ISAPNP_SysDevNodeCount) {
< 				LOG_MSG("ISAPNP Get System Device Node: Invalid Node 0x%02x (max 0x%04x)\n",(int)Node,(int)ISAPNP_SysDevNodeCount);
< 				reg_ax = 0x84;/* BAD_PARAMETER */
< 				break;
< 			}
< 
< 			ISAPNP_SysDevNode *nd = ISAPNP_SysDevNodes[Node];
< 
< 			mem_writew(devNodeBuffer_ptr+0,nd->raw_len+3); /* Length */
< 			mem_writeb(devNodeBuffer_ptr+2,Node); /* on most PnP BIOS implementations I've seen "handle" is set to the same value as Node */
< 			for (i=0;i < (Bitu)nd->raw_len;i++)
< 				mem_writeb(devNodeBuffer_ptr+i+3,nd->raw[i]);
< 
< //			LOG_MSG("ISAPNP OS asked for Node 0x%02x\n",Node);
< 
< 			if (++Node >= ISAPNP_SysDevNodeCount) Node = 0xFF; /* no more nodes */
< 			mem_writeb(Node_ptr,Node);
< 
< 			reg_ax = 0x00;/* SUCCESS */
< 		} break;
< 		case 4: {		/* Send Message */
< 			/* int __cdecl FAR (*entrypoint)(int Function,unsigned int Message,unsigned int BiosSelector);
< 			 *                               ^ +0         ^ +2                 ^ +4                        = 6 */
< 			Bitu Message = mem_readw(arg+2);
< 			BiosSelector = mem_readw(arg+4);
< 
< 			if (!ISAPNP_Verify_BiosSelector(BiosSelector))
< 				goto badBiosSelector;
< 
< 			switch (Message) {
< 				case 0x41:	/* POWER_OFF */
< 					LOG_MSG("Plug & Play OS requested power off.\n");
< 					throw 1;	/* NTS: Based on the Reboot handler code, causes DOSBox to cleanly shutdown and exit */
< 					reg_ax = 0;
< 					break;
< 				case 0x42:	/* PNP_OS_ACTIVE */
< 					LOG_MSG("Plug & Play OS reports itself active\n");
< 					reg_ax = 0;
< 					break;
< 				case 0x43:	/* PNP_OS_INACTIVE */
< 					LOG_MSG("Plug & Play OS reports itself inactive\n");
< 					reg_ax = 0;
< 					break;
< 				default:
< 					LOG_MSG("Unknown ISA PnP message 0x%04x\n",(int)Message);
< 					reg_ax = 0x82;/* FUNCTION_NOT_SUPPORTED */
< 					break;
< 			}
< 		} break;
< 		case 0x40: {		/* Get PnP ISA configuration */
< 			/* int __cdecl FAR (*entrypoint)(int Function,unsigned char far *struct,unsigned int BiosSelector);
< 			 *                               ^ +0         ^ +2                      ^ +6                        = 8 */
< 			Bitu struct_ptr = mem_readd(arg+2);
< 			BiosSelector = mem_readw(arg+6);
< 
< 			if (!ISAPNP_Verify_BiosSelector(BiosSelector))
< 				goto badBiosSelector;
< 
< 			/* struct isapnp_pnp_isa_cfg {
< 				 uint8_t	revision;
< 				 uint8_t	total_csn;
< 				 uint16_t	isa_pnp_port;
< 				 uint16_t	reserved;
< 			 }; */
< 
< 			if (struct_ptr != 0) {
< 				Bitu ph = ISAPNP_xlate_address(struct_ptr);
< 				mem_writeb(ph+0,0x01);		/* ->revision = 0x01 */
< 				mem_writeb(ph+1,ISA_PNP_devnext); /* ->total_csn */
< 				mem_writew(ph+2,ISA_PNP_WPORT_BIOS);	/* ->isa_pnp_port */
< 				mem_writew(ph+4,0);		/* ->reserved */
< 			}
< 
< 			reg_ax = 0x00;/* SUCCESS */
< 		} break;
< 		default:
< 			//LOG_MSG("Unsupported ISA PnP function 0x%04x\n",func);
< 			reg_ax = 0x82;/* FUNCTION_NOT_SUPPORTED */
< 			break;
< 	};
< 
< 	return 0;
< badBiosSelector:
< 	/* return an error. remind the user (possible developer) how lucky he is, a real
< 	 * BIOS implementation would CRASH when misused like this */
< 	LOG_MSG("ISA PnP function 0x%04x called with incorrect BiosSelector parameter 0x%04x\n",(int)func,(int)BiosSelector);
< 	LOG_MSG(" > STACK %04X %04X %04X %04X %04X %04X %04X %04X\n",
< 		mem_readw(arg),		mem_readw(arg+2),	mem_readw(arg+4),	mem_readw(arg+6),
< 		mem_readw(arg+8),	mem_readw(arg+10),	mem_readw(arg+12),	mem_readw(arg+14));
< 
< 	reg_ax = 0x84;/* BAD_PARAMETER */
< 	return 0;
< }
< 
< static Bitu ISAPNP_Handler_PM(void) {
< 	return ISAPNP_Handler(true);
< }
< 
< static Bitu ISAPNP_Handler_RM(void) {
< 	return ISAPNP_Handler(false);
< }
4270,4276d3187
< bool bios_user_reset_vector_blob_run = false;
< Bitu bios_user_reset_vector_blob = 0;
< 
< Bitu bios_user_boot_hook = 0;
< 
< void CALLBACK_DeAllocate(Bitu in);
< 
4299a3211,3214
> void CALLBACK_DeAllocate(Bitu in);
> 
> void BIOS_OnResetComplete(Section *x);
> 
4304,4306d3218
< #if C_DEBUG
<         void DEBUG_CheckCSIP();
< #endif
4329,4345d3240
<         if (bios_user_reset_vector_blob != 0 && !bios_user_reset_vector_blob_run) {
<             LOG_MSG("BIOS POST: Running user reset vector blob at 0x%lx",(unsigned long)bios_user_reset_vector_blob);
<             bios_user_reset_vector_blob_run = true;
< 
<             assert((bios_user_reset_vector_blob&0xF) == 0); /* must be page aligned */
< 
<             SegSet16(cs,bios_user_reset_vector_blob>>4);
<             reg_eip = 0;
< 
< #if C_DEBUG
<             /* help the debugger reflect the new instruction pointer */
<             DEBUG_CheckCSIP();
< #endif
< 
<             return CBRET_NONE;
<         }
< 
4624a3521
> 		/* Some hardcoded vectors */
4803,4811d3698
< 		if (!IS_PC98_ARCH) {
< 			ISAPNP_PNP_ADDRESS_PORT = new IO_WriteHandleObject;
< 			ISAPNP_PNP_ADDRESS_PORT->Install(0x279,isapnp_write_port,IO_MB);
< 			ISAPNP_PNP_DATA_PORT = new IO_WriteHandleObject;
< 			ISAPNP_PNP_DATA_PORT->Install(0xA79,isapnp_write_port,IO_MB);
< 			ISAPNP_PNP_READ_PORT = new IO_ReadHandleObject;
< 			ISAPNP_PNP_READ_PORT->Install(ISA_PNP_WPORT,isapnp_read_port,IO_MB);
< 			LOG(LOG_MISC,LOG_DEBUG)("Registered ISA PnP read port at 0x%03x",ISA_PNP_WPORT);
< 		}
4828,4831c3715
<             if (isapnpigdevice == NULL && enable_integration_device_pnp) {
<                 isapnpigdevice = new ISAPnPIntegrationDevice;
<                 ISA_PNP_devreg(isapnpigdevice);
<             }
---
> 
4836,5042d3719
< 		if (!IS_PC98_ARCH && ISAPNPBIOS) {
< 			int i;
< 			Bitu base;
< 			unsigned char c,tmp[256];
< 
< 			if (mainline_compatible_bios_mapping)
< 				isapnp_biosstruct_base = base = 0xFE100; /* take the unused space just after the fake BIOS signature */
< 			else
< 				isapnp_biosstruct_base = base = ROMBIOS_GetMemory(0x21,"ISA Plug & Play BIOS struct",/*paragraph alignment*/0x10);
< 
< 			if (base == 0) E_Exit("Unable to allocate ISA PnP struct");
< 			LOG_MSG("ISA Plug & Play BIOS enabled");
< 
< 			call_pnp_r = CALLBACK_Allocate();
< 			call_pnp_rp = PNPentry_real = CALLBACK_RealPointer(call_pnp_r);
< 			CALLBACK_Setup(call_pnp_r,ISAPNP_Handler_RM,CB_RETF,"ISA Plug & Play entry point (real)");
< 			//LOG_MSG("real entry pt=%08lx\n",PNPentry_real);
< 
< 			call_pnp_p = CALLBACK_Allocate();
< 			call_pnp_pp = PNPentry_prot = CALLBACK_RealPointer(call_pnp_p);
< 			CALLBACK_Setup(call_pnp_p,ISAPNP_Handler_PM,CB_RETF,"ISA Plug & Play entry point (protected)");
< 			//LOG_MSG("prot entry pt=%08lx\n",PNPentry_prot);
< 
< 			phys_writeb(base+0,'$');
< 			phys_writeb(base+1,'P');
< 			phys_writeb(base+2,'n');
< 			phys_writeb(base+3,'P');
< 			phys_writeb(base+4,0x10);		/* Version:		1.0 */
< 			phys_writeb(base+5,0x21);		/* Length:		0x21 bytes */
< 			phys_writew(base+6,0x0000);		/* Control field:	Event notification not supported */
< 			/* skip checksum atm */
< 			phys_writed(base+9,0);			/* Event notify flag addr: (none) */
< 			phys_writed(base+0xD,call_pnp_rp);	/* Real-mode entry point */
< 			phys_writew(base+0x11,call_pnp_pp&0xFFFF); /* Protected mode offset */
< 			phys_writed(base+0x13,(call_pnp_pp >> 12) & 0xFFFF0); /* Protected mode code segment base */
< 			phys_writed(base+0x17,ISAPNP_ID('D','O','S',0,7,4,0));		/* OEM device identifier (DOSBox 0.740, get it?) */
< 			phys_writew(base+0x1B,0xF000);		/* real-mode data segment */
< 			phys_writed(base+0x1D,0xF0000);		/* protected mode data segment address */
< 			/* run checksum */
< 			c=0;
< 			for (i=0;i < 0x21;i++) {
< 				if (i != 8) c += phys_readb(base+i);
< 			}
< 			phys_writeb(base+8,0x100-c);		/* checksum value: set so that summing bytes across the struct == 0 */
< 
< 			/* input device (keyboard) */
< 			if (!ISAPNP_RegisterSysDev(ISAPNP_sysdev_Keyboard,sizeof(ISAPNP_sysdev_Keyboard),true))
< 				LOG_MSG("ISAPNP register failed\n");
< 
< 			/* input device (mouse) */
< 			if (!ISAPNP_RegisterSysDev(ISAPNP_sysdev_Mouse,sizeof(ISAPNP_sysdev_Mouse),true))
< 				LOG_MSG("ISAPNP register failed\n");
< 
< 			/* DMA controller */
< 			if (!ISAPNP_RegisterSysDev(ISAPNP_sysdev_DMA_Controller,sizeof(ISAPNP_sysdev_DMA_Controller),true))
< 				LOG_MSG("ISAPNP register failed\n");
< 
< 			/* Interrupt controller */
< 			if (!ISAPNP_RegisterSysDev(ISAPNP_sysdev_PIC,sizeof(ISAPNP_sysdev_PIC),true))
< 				LOG_MSG("ISAPNP register failed\n");
< 
< 			/* Timer */
< 			if (!ISAPNP_RegisterSysDev(ISAPNP_sysdev_Timer,sizeof(ISAPNP_sysdev_Timer),true))
< 				LOG_MSG("ISAPNP register failed\n");
< 
< 			/* Realtime clock */
< 			if (!ISAPNP_RegisterSysDev(ISAPNP_sysdev_RTC,sizeof(ISAPNP_sysdev_RTC),true))
< 				LOG_MSG("ISAPNP register failed\n");
< 
< 			/* PC speaker */
< 			if (!ISAPNP_RegisterSysDev(ISAPNP_sysdev_PC_Speaker,sizeof(ISAPNP_sysdev_PC_Speaker),true))
< 				LOG_MSG("ISAPNP register failed\n");
< 
< 			/* System board */
< 			if (!ISAPNP_RegisterSysDev(ISAPNP_sysdev_System_Board,sizeof(ISAPNP_sysdev_System_Board),true))
< 				LOG_MSG("ISAPNP register failed\n");
< 
< 			/* Motherboard PNP resources and general */
< 			if (!ISAPNP_RegisterSysDev(ISAPNP_sysdev_General_ISAPNP,sizeof(ISAPNP_sysdev_General_ISAPNP),true))
< 				LOG_MSG("ISAPNP register failed\n");
< 
< 			/* ISA bus, meaning, a computer with ISA slots.
< 			 * The purpose of this device is to convince Windows 95 to automatically install it's
< 			 * "ISA Plug and Play bus" so that PnP devices are recognized automatically */
< 			if (!ISAPNP_RegisterSysDev(ISAPNP_sysdev_ISA_BUS,sizeof(ISAPNP_sysdev_ISA_BUS),true))
< 				LOG_MSG("ISAPNP register failed\n");
< 
< 			if (pcibus_enable) {
< 				/* PCI bus, meaning, a computer with PCI slots.
< 				 * The purpose of this device is to tell Windows 95 that a PCI bus is present. Without
< 				 * this entry, PCI devices will not be recognized until you manually install the PCI driver. */
< 				if (!ISAPNP_RegisterSysDev(ISAPNP_sysdev_PCI_BUS,sizeof(ISAPNP_sysdev_PCI_BUS),true))
< 					LOG_MSG("ISAPNP register failed\n");
< 			}
< 
< 			/* APM BIOS device. To help Windows 95 see our APM BIOS. */
< 			if (APMBIOS && APMBIOS_pnp) {
< 				LOG_MSG("Registering APM BIOS as ISA Plug & Play BIOS device node");
< 				if (!ISAPNP_RegisterSysDev(ISAPNP_sysdev_APM_BIOS,sizeof(ISAPNP_sysdev_APM_BIOS),true))
< 					LOG_MSG("ISAPNP register failed\n");
< 			}
< 
< #if (C_FPU)
< 			/* Numeric Coprocessor */
< 			if (!ISAPNP_RegisterSysDev(ISAPNP_sysdev_Numeric_Coprocessor,sizeof(ISAPNP_sysdev_Numeric_Coprocessor),true))
< 				LOG_MSG("ISAPNP register failed\n");
< #endif
< 
< 			/* RAM resources. we have to construct it */
< 			/* NTS: We don't do this here, but I have an old Toshiba laptop who's PnP BIOS uses
< 			 *      this device ID to report both RAM and ROM regions. */
< 			{
< 				Bitu max = MEM_TotalPages() * 4096;
< 				const unsigned char h1[9] = {
< 					ISAPNP_SYSDEV_HEADER(
< 						ISAPNP_ID('P','N','P',0x0,0xC,0x0,0x1), /* PNP0C01 System device, motherboard resources */
< 						ISAPNP_TYPE(0x05,0x00,0x00),		/* type: Memory, RAM, general */
< 						0x0001 | 0x0002)
< 				};
< 
< 				i = 0;
< 				memcpy(tmp+i,h1,9); i += 9;			/* can't disable, can't configure */
< 				/*----------allocated--------*/
< 				tmp[i+0] = 0x80 | 6;				/* 32-bit memory range */
< 				tmp[i+1] = 9;					/* length=9 */
< 				tmp[i+2] = 0;
< 				tmp[i+3] = 0x01;				/* writeable, no cache, 8-bit, not shadowable, not ROM */
< 				host_writed(tmp+i+4,0x00000);			/* base */
< 				host_writed(tmp+i+8,max > 0xA0000 ? 0xA0000 : 0x00000); /* length */
< 				i += 9+3;
< 
< 				if (max > 0x100000) {
< 					tmp[i+0] = 0x80 | 6;				/* 32-bit memory range */
< 					tmp[i+1] = 9;					/* length=9 */
< 					tmp[i+2] = 0;
< 					tmp[i+3] = 0x01;
< 					host_writed(tmp+i+4,0x100000);			/* base */
< 					host_writed(tmp+i+8,max-0x100000);		/* length */
< 					i += 9+3;
< 				}
< 
< 				tmp[i+0] = 0x79;				/* END TAG */
< 				tmp[i+1] = 0x00;
< 				i += 2;
< 				/*-------------possible-----------*/
< 				tmp[i+0] = 0x79;				/* END TAG */
< 				tmp[i+1] = 0x00;
< 				i += 2;
< 				/*-------------compatible---------*/
< 				tmp[i+0] = 0x79;				/* END TAG */
< 				tmp[i+1] = 0x00;
< 				i += 2;
< 
< 				if (!ISAPNP_RegisterSysDev(tmp,i))
< 					LOG_MSG("ISAPNP register failed\n");
< 			}
< 
< 			/* register parallel ports */
< 			for (Bitu portn=0;portn < 3;portn++) {
< 				Bitu port = mem_readw(BIOS_ADDRESS_LPT1+(portn*2));
< 				if (port != 0) {
< 					const unsigned char h1[9] = {
< 						ISAPNP_SYSDEV_HEADER(
< 							ISAPNP_ID('P','N','P',0x0,0x4,0x0,0x0), /* PNP0400 Standard LPT printer port */
< 							ISAPNP_TYPE(0x07,0x01,0x00),		/* type: General parallel port */
< 							0x0001 | 0x0002)
< 					};
< 
< 					i = 0;
< 					memcpy(tmp+i,h1,9); i += 9;			/* can't disable, can't configure */
< 					/*----------allocated--------*/
< 					tmp[i+0] = (8 << 3) | 7;			/* IO resource */
< 					tmp[i+1] = 0x01;				/* 16-bit decode */
< 					host_writew(tmp+i+2,port);			/* min */
< 					host_writew(tmp+i+4,port);			/* max */
< 					tmp[i+6] = 0x10;				/* align */
< 					tmp[i+7] = 0x03;				/* length */
< 					i += 7+1;
< 
< 					/* TODO: If/when LPT emulation handles the IRQ, add IRQ resource here */
< 
< 					tmp[i+0] = 0x79;				/* END TAG */
< 					tmp[i+1] = 0x00;
< 					i += 2;
< 					/*-------------possible-----------*/
< 					tmp[i+0] = 0x79;				/* END TAG */
< 					tmp[i+1] = 0x00;
< 					i += 2;
< 					/*-------------compatible---------*/
< 					tmp[i+0] = 0x79;				/* END TAG */
< 					tmp[i+1] = 0x00;
< 					i += 2;
< 
< 					if (!ISAPNP_RegisterSysDev(tmp,i))
< 						LOG_MSG("ISAPNP register failed\n");
< 				}
< 			}
< 
< 			void BIOS_Post_register_comports_PNP();
< 			BIOS_Post_register_comports_PNP();
< 
<             void BIOS_Post_register_IDE();
<             BIOS_Post_register_IDE();
< 
<             void BIOS_Post_register_FDC();
<             BIOS_Post_register_FDC();
< 		}
5128c3805
< 		const char *msg = PACKAGE_STRING " (C) 2002-2018 The DOSBox Team\nA fork of DOSBox 0.74 by TheGreatCodeholio\nFor more info visit http://dosbox-x.com\nBased on DOSBox (http://dosbox.com)\n\n";
---
> 		const char *msg = PACKAGE_STRING " (C) 2002-2017 The DOSBox Team\nA fork of DOSBox 0.74 by TheGreatCodeholio\nFor more info visit http://dosbox-x.com\nBased on DOSBox (http://dosbox.com)\n\n";
5676,5684d4353
<             // user boot hook
<             if (bios_user_boot_hook != 0) {
<                 phys_writeb(wo+0x00,0x9C);                          //PUSHF
<                 phys_writeb(wo+0x01,0x9A);                          //CALL FAR
<                 phys_writew(wo+0x02,0x0000);                        //seg:0
<                 phys_writew(wo+0x04,bios_user_boot_hook>>4);
<                 wo += 6;
<             }
< 
5709,5724c4378
< 		if (ISAPNP_PNP_ADDRESS_PORT) {
< 			delete ISAPNP_PNP_ADDRESS_PORT;
< 			ISAPNP_PNP_ADDRESS_PORT=NULL;
< 		}
< 		if (ISAPNP_PNP_DATA_PORT) {
< 			delete ISAPNP_PNP_DATA_PORT;
< 			ISAPNP_PNP_DATA_PORT=NULL;
< 		}
< 		if (ISAPNP_PNP_READ_PORT) {
< 			delete ISAPNP_PNP_READ_PORT;
< 			ISAPNP_PNP_READ_PORT=NULL;
< 		}
<         if (isapnpigdevice) {
<             /* ISA PnP will auto-free it */
<             isapnpigdevice=NULL;
<         }
---
> 
5861c4515
< 		if (!ISAPNP_RegisterSysDev(tmp,i)) {
---
> 		//if (!ISAPNP_RegisterSysDev(tmp,i)) {
5863c4517
< 		}
---
> 		//}
5871d4524
< 	ISA_PNP_FreeAllDevs();
5915d4567
<     ISA_PNP_FreeAllSysNodeDevs();
5922,5924d4573
< 	ISAPNP_SysDevNodeCount = 0;
< 	ISAPNP_SysDevNodeLargest = 0;
< 	for (int i=0;i < MAX_ISA_PNP_SYSDEVNODES;i++) ISAPNP_SysDevNodes[i] = NULL;
6050,6119d4698
< 
<     /* we allow dosbox.conf to specify a binary blob to load into ROM BIOS and execute after reset.
<      * we allow this for both hacker curiosity and automated CPU testing. */
<     {
<         std::string path = section->Get_string("call binary on reset");
<         struct stat st;
< 
<         if (!path.empty() && stat(path.c_str(),&st) == 0 && S_ISREG(st.st_mode) && st.st_size <= (128*1024)) {
<             Bitu base = ROMBIOS_GetMemory(st.st_size,"User reset vector binary",16/*page align*/,0);
< 
<             if (base != 0) {
<                 FILE *fp = fopen(path.c_str(),"rb");
< 
<                 if (fp != NULL) {
<                     /* NTS: Make sure memory base != NULL, and that it fits within 1MB.
<                      *      memory code allocates a minimum 1MB of memory even if
<                      *      guest memory is less than 1MB because ROM BIOS emulation
<                      *      depends on it. */
<                     assert(GetMemBase() != NULL);
<                     assert((base+st.st_size) <= 0x100000);
<                     fread(GetMemBase()+base,st.st_size,1,fp);
<                     fclose(fp);
< 
<                     LOG_MSG("User reset vector binary '%s' loaded at 0x%lx",path.c_str(),(unsigned long)base);
<                     bios_user_reset_vector_blob = base;
<                 }
<                 else {
<                     LOG_MSG("WARNING: Unable to open file to load user reset vector binary '%s' into ROM BIOS memory",path.c_str());
<                 }
<             }
<             else {
<                 LOG_MSG("WARNING: Unable to load user reset vector binary '%s' into ROM BIOS memory",path.c_str());
<             }
<         }
<     }
< 
<     /* we allow dosbox.conf to specify a binary blob to load into ROM BIOS and execute just before boot.
<      * we allow this for both hacker curiosity and automated CPU testing. */
<     {
<         std::string path = section->Get_string("call binary on boot");
<         struct stat st;
< 
<         if (!path.empty() && stat(path.c_str(),&st) == 0 && S_ISREG(st.st_mode) && st.st_size <= (128*1024)) {
<             Bitu base = ROMBIOS_GetMemory(st.st_size,"User boot hook binary",16/*page align*/,0);
< 
<             if (base != 0) {
<                 FILE *fp = fopen(path.c_str(),"rb");
< 
<                 if (fp != NULL) {
<                     /* NTS: Make sure memory base != NULL, and that it fits within 1MB.
<                      *      memory code allocates a minimum 1MB of memory even if
<                      *      guest memory is less than 1MB because ROM BIOS emulation
<                      *      depends on it. */
<                     assert(GetMemBase() != NULL);
<                     assert((base+st.st_size) <= 0x100000);
<                     fread(GetMemBase()+base,st.st_size,1,fp);
<                     fclose(fp);
< 
<                     LOG_MSG("User boot hook binary '%s' loaded at 0x%lx",path.c_str(),(unsigned long)base);
<                     bios_user_boot_hook = base;
<                 }
<                 else {
<                     LOG_MSG("WARNING: Unable to open file to load user boot hook binary '%s' into ROM BIOS memory",path.c_str());
<                 }
<             }
<             else {
<                 LOG_MSG("WARNING: Unable to load user boot hook binary '%s' into ROM BIOS memory",path.c_str());
<             }
<         }
<     }
