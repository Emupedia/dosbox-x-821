; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.21022.08 

	TITLE	c:\dev\dosbox-x\vs2008\zlib\gzlib.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_02DKCKIIND@?$CFs?$AA@			; `string'
PUBLIC	??_C@_07EBNKNFJN@?$DMfd?3?$CFd?$DO?$AA@		; `string'
PUBLIC	??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@		; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_02LMMGGCAJ@?3?5?$AA@			; `string'
PUBLIC	??_C@_06DIJPEION@?$CFs?$CFs?$CFs?$AA@		; `string'
EXTRN	__imp__wcstombs:PROC
EXTRN	__imp___wopen:PROC
EXTRN	__imp__open:PROC
EXTRN	__imp___lseeki64:PROC
EXTRN	__imp___snprintf:PROC
EXTRN	_strlen:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp__malloc:PROC
;	COMDAT ??_C@_06DIJPEION@?$CFs?$CFs?$CFs?$AA@
CONST	SEGMENT
??_C@_06DIJPEION@?$CFs?$CFs?$CFs?$AA@ DB '%s%s%s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02LMMGGCAJ@?3?5?$AA@
CONST	SEGMENT
??_C@_02LMMGGCAJ@?3?5?$AA@ DB ': ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@
CONST	SEGMENT
??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@ DB 'out of memory', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07EBNKNFJN@?$DMfd?3?$CFd?$DO?$AA@
CONST	SEGMENT
??_C@_07EBNKNFJN@?$DMfd?3?$CFd?$DO?$AA@ DB '<fd:%d>', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs?$AA@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs?$AA@ DB '%s', 00H		; `string'
PUBLIC	_gz_error
; Function compile flags: /Odtp
; File c:\dev\dosbox-x\vs2008\zlib\gzlib.c
;	COMDAT _gz_error
_TEXT	SEGMENT
_state$ = 8						; size = 4
_err$ = 12						; size = 4
_msg$ = 16						; size = 4
_gz_error PROC						; COMDAT

; 579  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 580  :     /* free previously allocated message and clear */
; 581  :     if (state->msg != NULL) {

  00004	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00007	83 78 60 00	 cmp	 DWORD PTR [eax+96], 0
  0000b	74 23		 je	 SHORT $LN6@gz_error

; 582  :         if (state->err != Z_MEM_ERROR)

  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00010	83 79 5c fc	 cmp	 DWORD PTR [ecx+92], -4	; fffffffcH
  00014	74 10		 je	 SHORT $LN5@gz_error

; 583  :             free(state->msg);

  00016	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00019	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  0001c	50		 push	 eax
  0001d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00023	83 c4 04	 add	 esp, 4
$LN5@gz_error:

; 584  :         state->msg = NULL;

  00026	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00029	c7 41 60 00 00
	00 00		 mov	 DWORD PTR [ecx+96], 0
$LN6@gz_error:

; 585  :     }
; 586  : 
; 587  :     /* if fatal, set state->x.have to 0 so that the gzgetc() macro fails */
; 588  :     if (err != Z_OK && err != Z_BUF_ERROR)

  00030	83 7d 0c 00	 cmp	 DWORD PTR _err$[ebp], 0
  00034	74 0f		 je	 SHORT $LN4@gz_error
  00036	83 7d 0c fb	 cmp	 DWORD PTR _err$[ebp], -5 ; fffffffbH
  0003a	74 09		 je	 SHORT $LN4@gz_error

; 589  :         state->x.have = 0;

  0003c	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0003f	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
$LN4@gz_error:

; 590  : 
; 591  :     /* set error code, and if no message, then done */
; 592  :     state->err = err;

  00045	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00048	8b 4d 0c	 mov	 ecx, DWORD PTR _err$[ebp]
  0004b	89 48 5c	 mov	 DWORD PTR [eax+92], ecx

; 593  :     if (msg == NULL)

  0004e	83 7d 10 00	 cmp	 DWORD PTR _msg$[ebp], 0
  00052	75 05		 jne	 SHORT $LN3@gz_error

; 594  :         return;

  00054	e9 98 00 00 00	 jmp	 $LN7@gz_error
$LN3@gz_error:

; 595  : 
; 596  :     /* for an out of memory error, return literal string when requested */
; 597  :     if (err == Z_MEM_ERROR)

  00059	83 7d 0c fc	 cmp	 DWORD PTR _err$[ebp], -4 ; fffffffcH
  0005d	75 05		 jne	 SHORT $LN2@gz_error

; 598  :         return;

  0005f	e9 8d 00 00 00	 jmp	 $LN7@gz_error
$LN2@gz_error:

; 599  : 
; 600  :     /* construct error message with path */
; 601  :     if ((state->msg = (char *)malloc(strlen(state->path) + strlen(msg) + 3)) ==
; 602  :             NULL) {

  00064	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00067	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0006a	50		 push	 eax
  0006b	e8 00 00 00 00	 call	 _strlen
  00070	83 c4 04	 add	 esp, 4
  00073	8b f0		 mov	 esi, eax
  00075	8b 4d 10	 mov	 ecx, DWORD PTR _msg$[ebp]
  00078	51		 push	 ecx
  00079	e8 00 00 00 00	 call	 _strlen
  0007e	83 c4 04	 add	 esp, 4
  00081	8d 54 06 03	 lea	 edx, DWORD PTR [esi+eax+3]
  00085	52		 push	 edx
  00086	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0008c	83 c4 04	 add	 esp, 4
  0008f	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00092	89 41 60	 mov	 DWORD PTR [ecx+96], eax
  00095	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00098	83 7a 60 00	 cmp	 DWORD PTR [edx+96], 0
  0009c	75 0c		 jne	 SHORT $LN1@gz_error

; 603  :         state->err = Z_MEM_ERROR;

  0009e	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000a1	c7 40 5c fc ff
	ff ff		 mov	 DWORD PTR [eax+92], -4	; fffffffcH

; 604  :         return;

  000a8	eb 47		 jmp	 SHORT $LN7@gz_error
$LN1@gz_error:

; 605  :     }
; 606  : #if !defined(NO_snprintf) && !defined(NO_vsnprintf)
; 607  :     snprintf(state->msg, strlen(state->path) + strlen(msg) + 3,
; 608  :              "%s%s%s", state->path, ": ", msg);

  000aa	8b 4d 10	 mov	 ecx, DWORD PTR _msg$[ebp]
  000ad	51		 push	 ecx
  000ae	68 00 00 00 00	 push	 OFFSET ??_C@_02LMMGGCAJ@?3?5?$AA@
  000b3	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  000b6	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  000b9	50		 push	 eax
  000ba	68 00 00 00 00	 push	 OFFSET ??_C@_06DIJPEION@?$CFs?$CFs?$CFs?$AA@
  000bf	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  000c2	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  000c5	52		 push	 edx
  000c6	e8 00 00 00 00	 call	 _strlen
  000cb	83 c4 04	 add	 esp, 4
  000ce	8b f0		 mov	 esi, eax
  000d0	8b 45 10	 mov	 eax, DWORD PTR _msg$[ebp]
  000d3	50		 push	 eax
  000d4	e8 00 00 00 00	 call	 _strlen
  000d9	83 c4 04	 add	 esp, 4
  000dc	8d 4c 06 03	 lea	 ecx, DWORD PTR [esi+eax+3]
  000e0	51		 push	 ecx
  000e1	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  000e4	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  000e7	50		 push	 eax
  000e8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___snprintf
  000ee	83 c4 18	 add	 esp, 24			; 00000018H
$LN7@gz_error:

; 609  : #else
; 610  :     strcpy(state->msg, state->path);
; 611  :     strcat(state->msg, ": ");
; 612  :     strcat(state->msg, msg);
; 613  : #endif
; 614  :     return;
; 615  : }

  000f1	5e		 pop	 esi
  000f2	5d		 pop	 ebp
  000f3	c3		 ret	 0
_gz_error ENDP
_TEXT	ENDS
PUBLIC	_gzclearerr@4
; Function compile flags: /Odtp
;	COMDAT _gzclearerr@4
_TEXT	SEGMENT
_state$ = -4						; size = 4
_file$ = 8						; size = 4
_gzclearerr@4 PROC					; COMDAT

; 551  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 552  :     gz_statep state;
; 553  : 
; 554  :     /* get internal structure and check integrity */
; 555  :     if (file == NULL)

  00004	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  00008	75 02		 jne	 SHORT $LN3@gzclearerr

; 556  :         return;

  0000a	eb 50		 jmp	 SHORT $LN4@gzclearerr
$LN3@gzclearerr:

; 557  :     state = (gz_statep)file;

  0000c	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  0000f	89 45 fc	 mov	 DWORD PTR _state$[ebp], eax

; 558  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  00012	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00015	81 79 10 4f 1c
	00 00		 cmp	 DWORD PTR [ecx+16], 7247 ; 00001c4fH
  0001c	74 0e		 je	 SHORT $LN2@gzclearerr
  0001e	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00021	81 7a 10 b1 79
	00 00		 cmp	 DWORD PTR [edx+16], 31153 ; 000079b1H
  00028	74 02		 je	 SHORT $LN2@gzclearerr

; 559  :         return;

  0002a	eb 30		 jmp	 SHORT $LN4@gzclearerr
$LN2@gzclearerr:

; 560  : 
; 561  :     /* clear error and end-of-file */
; 562  :     if (state->mode == GZ_READ) {

  0002c	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0002f	81 78 10 4f 1c
	00 00		 cmp	 DWORD PTR [eax+16], 7247 ; 00001c4fH
  00036	75 14		 jne	 SHORT $LN1@gzclearerr

; 563  :         state->eof = 0;

  00038	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0003b	c7 41 40 00 00
	00 00		 mov	 DWORD PTR [ecx+64], 0

; 564  :         state->past = 0;

  00042	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00045	c7 42 44 00 00
	00 00		 mov	 DWORD PTR [edx+68], 0
$LN1@gzclearerr:

; 565  :     }
; 566  :     gz_error(state, Z_OK, NULL);

  0004c	6a 00		 push	 0
  0004e	6a 00		 push	 0
  00050	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00053	50		 push	 eax
  00054	e8 00 00 00 00	 call	 _gz_error
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@gzclearerr:

; 567  : }

  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c2 04 00	 ret	 4
_gzclearerr@4 ENDP
_TEXT	ENDS
PUBLIC	_gzerror@8
; Function compile flags: /Odtp
;	COMDAT _gzerror@8
_TEXT	SEGMENT
tv76 = -12						; size = 4
tv77 = -8						; size = 4
_state$ = -4						; size = 4
_file$ = 8						; size = 4
_errnum$ = 12						; size = 4
_gzerror@8 PROC						; COMDAT

; 531  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 532  :     gz_statep state;
; 533  : 
; 534  :     /* get internal structure and check integrity */
; 535  :     if (file == NULL)

  00006	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  0000a	75 04		 jne	 SHORT $LN3@gzerror

; 536  :         return NULL;

  0000c	33 c0		 xor	 eax, eax
  0000e	eb 69		 jmp	 SHORT $LN4@gzerror
$LN3@gzerror:

; 537  :     state = (gz_statep)file;

  00010	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00013	89 45 fc	 mov	 DWORD PTR _state$[ebp], eax

; 538  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  00016	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00019	81 79 10 4f 1c
	00 00		 cmp	 DWORD PTR [ecx+16], 7247 ; 00001c4fH
  00020	74 10		 je	 SHORT $LN2@gzerror
  00022	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00025	81 7a 10 b1 79
	00 00		 cmp	 DWORD PTR [edx+16], 31153 ; 000079b1H
  0002c	74 04		 je	 SHORT $LN2@gzerror

; 539  :         return NULL;

  0002e	33 c0		 xor	 eax, eax
  00030	eb 47		 jmp	 SHORT $LN4@gzerror
$LN2@gzerror:

; 540  : 
; 541  :     /* return error information */
; 542  :     if (errnum != NULL)

  00032	83 7d 0c 00	 cmp	 DWORD PTR _errnum$[ebp], 0
  00036	74 0b		 je	 SHORT $LN1@gzerror

; 543  :         *errnum = state->err;

  00038	8b 45 0c	 mov	 eax, DWORD PTR _errnum$[ebp]
  0003b	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0003e	8b 51 5c	 mov	 edx, DWORD PTR [ecx+92]
  00041	89 10		 mov	 DWORD PTR [eax], edx
$LN1@gzerror:

; 544  :     return state->err == Z_MEM_ERROR ? "out of memory" :
; 545  :                                        (state->msg == NULL ? "" : state->msg);

  00043	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00046	83 78 5c fc	 cmp	 DWORD PTR [eax+92], -4	; fffffffcH
  0004a	75 09		 jne	 SHORT $LN8@gzerror
  0004c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv77[ebp], OFFSET ??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@
  00053	eb 21		 jmp	 SHORT $LN9@gzerror
$LN8@gzerror:
  00055	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00058	83 79 60 00	 cmp	 DWORD PTR [ecx+96], 0
  0005c	75 09		 jne	 SHORT $LN6@gzerror
  0005e	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv76[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
  00065	eb 09		 jmp	 SHORT $LN7@gzerror
$LN6@gzerror:
  00067	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0006a	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  0006d	89 45 f4	 mov	 DWORD PTR tv76[ebp], eax
$LN7@gzerror:
  00070	8b 4d f4	 mov	 ecx, DWORD PTR tv76[ebp]
  00073	89 4d f8	 mov	 DWORD PTR tv77[ebp], ecx
$LN9@gzerror:
  00076	8b 45 f8	 mov	 eax, DWORD PTR tv77[ebp]
$LN4@gzerror:

; 546  : }

  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c2 08 00	 ret	 8
_gzerror@8 ENDP
_TEXT	ENDS
PUBLIC	_gzeof@4
; Function compile flags: /Odtp
;	COMDAT _gzeof@4
_TEXT	SEGMENT
tv72 = -8						; size = 4
_state$ = -4						; size = 4
_file$ = 8						; size = 4
_gzeof@4 PROC						; COMDAT

; 513  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 514  :     gz_statep state;
; 515  : 
; 516  :     /* get internal structure and check integrity */
; 517  :     if (file == NULL)

  00006	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  0000a	75 04		 jne	 SHORT $LN2@gzeof

; 518  :         return 0;

  0000c	33 c0		 xor	 eax, eax
  0000e	eb 43		 jmp	 SHORT $LN3@gzeof
$LN2@gzeof:

; 519  :     state = (gz_statep)file;

  00010	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00013	89 45 fc	 mov	 DWORD PTR _state$[ebp], eax

; 520  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  00016	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00019	81 79 10 4f 1c
	00 00		 cmp	 DWORD PTR [ecx+16], 7247 ; 00001c4fH
  00020	74 10		 je	 SHORT $LN1@gzeof
  00022	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00025	81 7a 10 b1 79
	00 00		 cmp	 DWORD PTR [edx+16], 31153 ; 000079b1H
  0002c	74 04		 je	 SHORT $LN1@gzeof

; 521  :         return 0;

  0002e	33 c0		 xor	 eax, eax
  00030	eb 21		 jmp	 SHORT $LN3@gzeof
$LN1@gzeof:

; 522  : 
; 523  :     /* return end-of-file state */
; 524  :     return state->mode == GZ_READ ? state->past : 0;

  00032	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00035	81 78 10 4f 1c
	00 00		 cmp	 DWORD PTR [eax+16], 7247 ; 00001c4fH
  0003c	75 0b		 jne	 SHORT $LN5@gzeof
  0003e	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00041	8b 51 44	 mov	 edx, DWORD PTR [ecx+68]
  00044	89 55 f8	 mov	 DWORD PTR tv72[ebp], edx
  00047	eb 07		 jmp	 SHORT $LN6@gzeof
$LN5@gzeof:
  00049	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv72[ebp], 0
$LN6@gzeof:
  00050	8b 45 f8	 mov	 eax, DWORD PTR tv72[ebp]
$LN3@gzeof:

; 525  : }

  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c2 04 00	 ret	 4
_gzeof@4 ENDP
_TEXT	ENDS
PUBLIC	_gzoffset64@4
; Function compile flags: /Odtp
;	COMDAT _gzoffset64@4
_TEXT	SEGMENT
_state$ = -12						; size = 4
_offset$ = -8						; size = 8
_file$ = 8						; size = 4
_gzoffset64@4 PROC					; COMDAT

; 480  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 481  :     z_off64_t offset;
; 482  :     gz_statep state;
; 483  : 
; 484  :     /* get internal structure and check integrity */
; 485  :     if (file == NULL)

  00006	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  0000a	75 08		 jne	 SHORT $LN4@gzoffset64

; 486  :         return -1;

  0000c	83 c8 ff	 or	 eax, -1
  0000f	83 ca ff	 or	 edx, -1
  00012	eb 7f		 jmp	 SHORT $LN5@gzoffset64
$LN4@gzoffset64:

; 487  :     state = (gz_statep)file;

  00014	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00017	89 45 f4	 mov	 DWORD PTR _state$[ebp], eax

; 488  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  0001a	8b 4d f4	 mov	 ecx, DWORD PTR _state$[ebp]
  0001d	81 79 10 4f 1c
	00 00		 cmp	 DWORD PTR [ecx+16], 7247 ; 00001c4fH
  00024	74 14		 je	 SHORT $LN3@gzoffset64
  00026	8b 55 f4	 mov	 edx, DWORD PTR _state$[ebp]
  00029	81 7a 10 b1 79
	00 00		 cmp	 DWORD PTR [edx+16], 31153 ; 000079b1H
  00030	74 08		 je	 SHORT $LN3@gzoffset64

; 489  :         return -1;

  00032	83 c8 ff	 or	 eax, -1
  00035	83 ca ff	 or	 edx, -1
  00038	eb 59		 jmp	 SHORT $LN5@gzoffset64
$LN3@gzoffset64:

; 490  : 
; 491  :     /* compute and return effective offset in file */
; 492  :     offset = LSEEK(state->fd, 0, SEEK_CUR);

  0003a	6a 01		 push	 1
  0003c	6a 00		 push	 0
  0003e	6a 00		 push	 0
  00040	8b 45 f4	 mov	 eax, DWORD PTR _state$[ebp]
  00043	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00046	51		 push	 ecx
  00047	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___lseeki64
  0004d	83 c4 10	 add	 esp, 16			; 00000010H
  00050	89 45 f8	 mov	 DWORD PTR _offset$[ebp], eax
  00053	89 55 fc	 mov	 DWORD PTR _offset$[ebp+4], edx

; 493  :     if (offset == -1)

  00056	8b 55 f8	 mov	 edx, DWORD PTR _offset$[ebp]
  00059	23 55 fc	 and	 edx, DWORD PTR _offset$[ebp+4]
  0005c	83 fa ff	 cmp	 edx, -1
  0005f	75 08		 jne	 SHORT $LN2@gzoffset64

; 494  :         return -1;

  00061	83 c8 ff	 or	 eax, -1
  00064	83 ca ff	 or	 edx, -1
  00067	eb 2a		 jmp	 SHORT $LN5@gzoffset64
$LN2@gzoffset64:

; 495  :     if (state->mode == GZ_READ)             /* reading */

  00069	8b 45 f4	 mov	 eax, DWORD PTR _state$[ebp]
  0006c	81 78 10 4f 1c
	00 00		 cmp	 DWORD PTR [eax+16], 7247 ; 00001c4fH
  00073	75 18		 jne	 SHORT $LN1@gzoffset64

; 496  :         offset -= state->strm.avail_in;     /* don't count buffered input */

  00075	8b 4d f4	 mov	 ecx, DWORD PTR _state$[ebp]
  00078	8b 51 68	 mov	 edx, DWORD PTR [ecx+104]
  0007b	33 c0		 xor	 eax, eax
  0007d	8b 4d f8	 mov	 ecx, DWORD PTR _offset$[ebp]
  00080	2b ca		 sub	 ecx, edx
  00082	8b 55 fc	 mov	 edx, DWORD PTR _offset$[ebp+4]
  00085	1b d0		 sbb	 edx, eax
  00087	89 4d f8	 mov	 DWORD PTR _offset$[ebp], ecx
  0008a	89 55 fc	 mov	 DWORD PTR _offset$[ebp+4], edx
$LN1@gzoffset64:

; 497  :     return offset;

  0008d	8b 45 f8	 mov	 eax, DWORD PTR _offset$[ebp]
  00090	8b 55 fc	 mov	 edx, DWORD PTR _offset$[ebp+4]
$LN5@gzoffset64:

; 498  : }

  00093	8b e5		 mov	 esp, ebp
  00095	5d		 pop	 ebp
  00096	c2 04 00	 ret	 4
_gzoffset64@4 ENDP
_TEXT	ENDS
PUBLIC	_gztell64@4
; Function compile flags: /Odtp
;	COMDAT _gztell64@4
_TEXT	SEGMENT
tv73 = -12						; size = 8
_state$ = -4						; size = 4
_file$ = 8						; size = 4
_gztell64@4 PROC					; COMDAT

; 453  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 454  :     gz_statep state;
; 455  : 
; 456  :     /* get internal structure and check integrity */
; 457  :     if (file == NULL)

  00006	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  0000a	75 08		 jne	 SHORT $LN2@gztell64

; 458  :         return -1;

  0000c	83 c8 ff	 or	 eax, -1
  0000f	83 ca ff	 or	 edx, -1
  00012	eb 5d		 jmp	 SHORT $LN3@gztell64
$LN2@gztell64:

; 459  :     state = (gz_statep)file;

  00014	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00017	89 45 fc	 mov	 DWORD PTR _state$[ebp], eax

; 460  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0001d	81 79 10 4f 1c
	00 00		 cmp	 DWORD PTR [ecx+16], 7247 ; 00001c4fH
  00024	74 14		 je	 SHORT $LN1@gztell64
  00026	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00029	81 7a 10 b1 79
	00 00		 cmp	 DWORD PTR [edx+16], 31153 ; 000079b1H
  00030	74 08		 je	 SHORT $LN1@gztell64

; 461  :         return -1;

  00032	83 c8 ff	 or	 eax, -1
  00035	83 ca ff	 or	 edx, -1
  00038	eb 37		 jmp	 SHORT $LN3@gztell64
$LN1@gztell64:

; 462  : 
; 463  :     /* return position */
; 464  :     return state->x.pos + (state->seek ? state->skip : 0);

  0003a	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0003d	83 78 58 00	 cmp	 DWORD PTR [eax+88], 0
  00041	74 11		 je	 SHORT $LN5@gztell64
  00043	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00046	8b 51 50	 mov	 edx, DWORD PTR [ecx+80]
  00049	89 55 f4	 mov	 DWORD PTR tv73[ebp], edx
  0004c	8b 41 54	 mov	 eax, DWORD PTR [ecx+84]
  0004f	89 45 f8	 mov	 DWORD PTR tv73[ebp+4], eax
  00052	eb 0e		 jmp	 SHORT $LN6@gztell64
$LN5@gztell64:
  00054	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
  0005b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv73[ebp+4], 0
$LN6@gztell64:
  00062	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00065	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00068	03 45 f4	 add	 eax, DWORD PTR tv73[ebp]
  0006b	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0006e	13 55 f8	 adc	 edx, DWORD PTR tv73[ebp+4]
$LN3@gztell64:

; 465  : }

  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c2 04 00	 ret	 4
_gztell64@4 ENDP
_TEXT	ENDS
PUBLIC	_gzbuffer@8
; Function compile flags: /Odtp
;	COMDAT _gzbuffer@8
_TEXT	SEGMENT
_state$ = -4						; size = 4
_file$ = 8						; size = 4
_size$ = 12						; size = 4
_gzbuffer@8 PROC					; COMDAT

; 317  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 318  :     gz_statep state;
; 319  : 
; 320  :     /* get internal structure and check integrity */
; 321  :     if (file == NULL)

  00004	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  00008	75 05		 jne	 SHORT $LN4@gzbuffer

; 322  :         return -1;

  0000a	83 c8 ff	 or	 eax, -1
  0000d	eb 49		 jmp	 SHORT $LN5@gzbuffer
$LN4@gzbuffer:

; 323  :     state = (gz_statep)file;

  0000f	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR _state$[ebp], eax

; 324  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  00015	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00018	81 79 10 4f 1c
	00 00		 cmp	 DWORD PTR [ecx+16], 7247 ; 00001c4fH
  0001f	74 11		 je	 SHORT $LN3@gzbuffer
  00021	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00024	81 7a 10 b1 79
	00 00		 cmp	 DWORD PTR [edx+16], 31153 ; 000079b1H
  0002b	74 05		 je	 SHORT $LN3@gzbuffer

; 325  :         return -1;

  0002d	83 c8 ff	 or	 eax, -1
  00030	eb 26		 jmp	 SHORT $LN5@gzbuffer
$LN3@gzbuffer:

; 326  : 
; 327  :     /* make sure we haven't already allocated memory */
; 328  :     if (state->size != 0)

  00032	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00035	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  00039	74 05		 je	 SHORT $LN2@gzbuffer

; 329  :         return -1;

  0003b	83 c8 ff	 or	 eax, -1
  0003e	eb 18		 jmp	 SHORT $LN5@gzbuffer
$LN2@gzbuffer:

; 330  : 
; 331  :     /* check and set requested size */
; 332  :     if (size < 2)

  00040	83 7d 0c 02	 cmp	 DWORD PTR _size$[ebp], 2
  00044	73 07		 jae	 SHORT $LN1@gzbuffer

; 333  :         size = 2;               /* need two bytes to check magic header */

  00046	c7 45 0c 02 00
	00 00		 mov	 DWORD PTR _size$[ebp], 2
$LN1@gzbuffer:

; 334  :     state->want = size;

  0004d	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00050	8b 55 0c	 mov	 edx, DWORD PTR _size$[ebp]
  00053	89 51 20	 mov	 DWORD PTR [ecx+32], edx

; 335  :     return 0;

  00056	33 c0		 xor	 eax, eax
$LN5@gzbuffer:

; 336  : }

  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c2 08 00	 ret	 8
_gzbuffer@8 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _gz_reset
_TEXT	SEGMENT
_state$ = 8						; size = 4
_gz_reset PROC						; COMDAT

; 77   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 78   :     state->x.have = 0;              /* no output data available */

  00003	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00006	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 79   :     if (state->mode == GZ_READ) {   /* for reading ... */

  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0000f	81 79 10 4f 1c
	00 00		 cmp	 DWORD PTR [ecx+16], 7247 ; 00001c4fH
  00016	75 1e		 jne	 SHORT $LN1@gz_reset

; 80   :         state->eof = 0;             /* not at end of file */

  00018	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0001b	c7 42 40 00 00
	00 00		 mov	 DWORD PTR [edx+64], 0

; 81   :         state->past = 0;            /* have not read past end yet */

  00022	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00025	c7 40 44 00 00
	00 00		 mov	 DWORD PTR [eax+68], 0

; 82   :         state->how = LOOK;          /* look for gzip header */

  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0002f	c7 41 30 00 00
	00 00		 mov	 DWORD PTR [ecx+48], 0
$LN1@gz_reset:

; 83   :     }
; 84   :     state->seek = 0;                /* no seek request pending */

  00036	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00039	c7 42 58 00 00
	00 00		 mov	 DWORD PTR [edx+88], 0

; 85   :     gz_error(state, Z_OK, NULL);    /* clear error */

  00040	6a 00		 push	 0
  00042	6a 00		 push	 0
  00044	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 _gz_error
  0004d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 86   :     state->x.pos = 0;               /* no uncompressed data yet */

  00050	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00053	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  0005a	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 87   :     state->strm.avail_in = 0;       /* no input data yet */

  00061	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00064	c7 42 68 00 00
	00 00		 mov	 DWORD PTR [edx+104], 0

; 88   : }

  0006b	5d		 pop	 ebp
  0006c	c3		 ret	 0
_gz_reset ENDP
PUBLIC	_gzoffset@4
; Function compile flags: /Odtp
;	COMDAT _gzoffset@4
_TEXT	SEGMENT
tv70 = -20						; size = 4
tv83 = -16						; size = 8
_ret$ = -8						; size = 8
_file$ = 8						; size = 4
_gzoffset@4 PROC					; COMDAT

; 503  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 504  :     z_off64_t ret;
; 505  : 
; 506  :     ret = gzoffset64(file);

  00006	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _gzoffset64@4
  0000f	89 45 f8	 mov	 DWORD PTR _ret$[ebp], eax
  00012	89 55 fc	 mov	 DWORD PTR _ret$[ebp+4], edx

; 507  :     return ret == (z_off_t)ret ? (z_off_t)ret : -1;

  00015	8b 45 f8	 mov	 eax, DWORD PTR _ret$[ebp]
  00018	99		 cdq
  00019	89 45 f0	 mov	 DWORD PTR tv83[ebp], eax
  0001c	89 55 f4	 mov	 DWORD PTR tv83[ebp+4], edx
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR _ret$[ebp]
  00022	3b 4d f0	 cmp	 ecx, DWORD PTR tv83[ebp]
  00025	75 10		 jne	 SHORT $LN3@gzoffset
  00027	8b 55 fc	 mov	 edx, DWORD PTR _ret$[ebp+4]
  0002a	3b 55 f4	 cmp	 edx, DWORD PTR tv83[ebp+4]
  0002d	75 08		 jne	 SHORT $LN3@gzoffset
  0002f	8b 45 f8	 mov	 eax, DWORD PTR _ret$[ebp]
  00032	89 45 ec	 mov	 DWORD PTR tv70[ebp], eax
  00035	eb 07		 jmp	 SHORT $LN4@gzoffset
$LN3@gzoffset:
  00037	c7 45 ec ff ff
	ff ff		 mov	 DWORD PTR tv70[ebp], -1
$LN4@gzoffset:
  0003e	8b 45 ec	 mov	 eax, DWORD PTR tv70[ebp]

; 508  : }

  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
_gzoffset@4 ENDP
_TEXT	ENDS
PUBLIC	_gztell@4
; Function compile flags: /Odtp
;	COMDAT _gztell@4
_TEXT	SEGMENT
tv70 = -20						; size = 4
tv83 = -16						; size = 8
_ret$ = -8						; size = 8
_file$ = 8						; size = 4
_gztell@4 PROC						; COMDAT

; 470  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 471  :     z_off64_t ret;
; 472  : 
; 473  :     ret = gztell64(file);

  00006	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _gztell64@4
  0000f	89 45 f8	 mov	 DWORD PTR _ret$[ebp], eax
  00012	89 55 fc	 mov	 DWORD PTR _ret$[ebp+4], edx

; 474  :     return ret == (z_off_t)ret ? (z_off_t)ret : -1;

  00015	8b 45 f8	 mov	 eax, DWORD PTR _ret$[ebp]
  00018	99		 cdq
  00019	89 45 f0	 mov	 DWORD PTR tv83[ebp], eax
  0001c	89 55 f4	 mov	 DWORD PTR tv83[ebp+4], edx
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR _ret$[ebp]
  00022	3b 4d f0	 cmp	 ecx, DWORD PTR tv83[ebp]
  00025	75 10		 jne	 SHORT $LN3@gztell
  00027	8b 55 fc	 mov	 edx, DWORD PTR _ret$[ebp+4]
  0002a	3b 55 f4	 cmp	 edx, DWORD PTR tv83[ebp+4]
  0002d	75 08		 jne	 SHORT $LN3@gztell
  0002f	8b 45 f8	 mov	 eax, DWORD PTR _ret$[ebp]
  00032	89 45 ec	 mov	 DWORD PTR tv70[ebp], eax
  00035	eb 07		 jmp	 SHORT $LN4@gztell
$LN3@gztell:
  00037	c7 45 ec ff ff
	ff ff		 mov	 DWORD PTR tv70[ebp], -1
$LN4@gztell:
  0003e	8b 45 ec	 mov	 eax, DWORD PTR tv70[ebp]

; 475  : }

  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
_gztell@4 ENDP
_TEXT	ENDS
PUBLIC	_gzrewind@4
; Function compile flags: /Odtp
;	COMDAT _gzrewind@4
_TEXT	SEGMENT
tv130 = -12						; size = 8
_state$ = -4						; size = 4
_file$ = 8						; size = 4
_gzrewind@4 PROC					; COMDAT

; 341  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 342  :     gz_statep state;
; 343  : 
; 344  :     /* get internal structure */
; 345  :     if (file == NULL)

  00006	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  0000a	75 05		 jne	 SHORT $LN4@gzrewind

; 346  :         return -1;

  0000c	83 c8 ff	 or	 eax, -1
  0000f	eb 6a		 jmp	 SHORT $LN5@gzrewind
$LN4@gzrewind:

; 347  :     state = (gz_statep)file;

  00011	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00014	89 45 fc	 mov	 DWORD PTR _state$[ebp], eax

; 348  : 
; 349  :     /* check that we're reading and that there's no error */
; 350  :     if (state->mode != GZ_READ ||
; 351  :             (state->err != Z_OK && state->err != Z_BUF_ERROR))

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0001a	81 79 10 4f 1c
	00 00		 cmp	 DWORD PTR [ecx+16], 7247 ; 00001c4fH
  00021	75 12		 jne	 SHORT $LN2@gzrewind
  00023	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00026	83 7a 5c 00	 cmp	 DWORD PTR [edx+92], 0
  0002a	74 0e		 je	 SHORT $LN3@gzrewind
  0002c	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0002f	83 78 5c fb	 cmp	 DWORD PTR [eax+92], -5	; fffffffbH
  00033	74 05		 je	 SHORT $LN3@gzrewind
$LN2@gzrewind:

; 352  :         return -1;

  00035	83 c8 ff	 or	 eax, -1
  00038	eb 41		 jmp	 SHORT $LN5@gzrewind
$LN3@gzrewind:

; 353  : 
; 354  :     /* back up and start over */
; 355  :     if (LSEEK(state->fd, state->start, SEEK_SET) == -1)

  0003a	6a 00		 push	 0
  0003c	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0003f	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  00042	52		 push	 edx
  00043	8b 41 38	 mov	 eax, DWORD PTR [ecx+56]
  00046	50		 push	 eax
  00047	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0004a	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0004d	52		 push	 edx
  0004e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___lseeki64
  00054	83 c4 10	 add	 esp, 16			; 00000010H
  00057	89 45 f4	 mov	 DWORD PTR tv130[ebp], eax
  0005a	89 55 f8	 mov	 DWORD PTR tv130[ebp+4], edx
  0005d	8b 45 f4	 mov	 eax, DWORD PTR tv130[ebp]
  00060	23 45 f8	 and	 eax, DWORD PTR tv130[ebp+4]
  00063	83 f8 ff	 cmp	 eax, -1
  00066	75 05		 jne	 SHORT $LN1@gzrewind

; 356  :         return -1;

  00068	83 c8 ff	 or	 eax, -1
  0006b	eb 0e		 jmp	 SHORT $LN5@gzrewind
$LN1@gzrewind:

; 357  :     gz_reset(state);

  0006d	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00070	51		 push	 ecx
  00071	e8 00 00 00 00	 call	 _gz_reset
  00076	83 c4 04	 add	 esp, 4

; 358  :     return 0;

  00079	33 c0		 xor	 eax, eax
$LN5@gzrewind:

; 359  : }

  0007b	8b e5		 mov	 esp, ebp
  0007d	5d		 pop	 ebp
  0007e	c2 04 00	 ret	 4
_gzrewind@4 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _gz_open
_TEXT	SEGMENT
tv311 = -36						; size = 4
tv191 = -32						; size = 4
tv192 = -28						; size = 4
tv178 = -24						; size = 4
tv85 = -20						; size = 4
_state$ = -16						; size = 4
_oflag$ = -12						; size = 4
_len$ = -8						; size = 4
_exclusive$ = -4					; size = 4
_path$ = 8						; size = 4
_fd$ = 12						; size = 4
_mode$ = 16						; size = 4
_gz_open PROC						; COMDAT

; 95   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H

; 96   :     gz_statep state;
; 97   :     size_t len;
; 98   :     int oflag;
; 99   : #ifdef O_CLOEXEC
; 100  :     int cloexec = 0;
; 101  : #endif
; 102  : #ifdef O_EXCL
; 103  :     int exclusive = 0;

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _exclusive$[ebp], 0

; 104  : #endif
; 105  : 
; 106  :     /* check input */
; 107  :     if (path == NULL)

  0000d	83 7d 08 00	 cmp	 DWORD PTR _path$[ebp], 0
  00011	75 07		 jne	 SHORT $LN35@gz_open

; 108  :         return NULL;

  00013	33 c0		 xor	 eax, eax
  00015	e9 ab 03 00 00	 jmp	 $LN36@gz_open
$LN35@gz_open:

; 109  : 
; 110  :     /* allocate gzFile structure to return */
; 111  :     state = (gz_statep)malloc(sizeof(gz_state));

  0001a	68 a0 00 00 00	 push	 160			; 000000a0H
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00025	83 c4 04	 add	 esp, 4
  00028	89 45 f0	 mov	 DWORD PTR _state$[ebp], eax

; 112  :     if (state == NULL)

  0002b	83 7d f0 00	 cmp	 DWORD PTR _state$[ebp], 0
  0002f	75 07		 jne	 SHORT $LN34@gz_open

; 113  :         return NULL;

  00031	33 c0		 xor	 eax, eax
  00033	e9 8d 03 00 00	 jmp	 $LN36@gz_open
$LN34@gz_open:

; 114  :     state->size = 0;            /* no buffers allocated yet */

  00038	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  0003b	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0

; 115  :     state->want = GZBUFSIZE;    /* requested buffer size */

  00042	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  00045	c7 41 20 00 20
	00 00		 mov	 DWORD PTR [ecx+32], 8192 ; 00002000H

; 116  :     state->msg = NULL;          /* no error message yet */

  0004c	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  0004f	c7 42 60 00 00
	00 00		 mov	 DWORD PTR [edx+96], 0

; 117  : 
; 118  :     /* interpret mode */
; 119  :     state->mode = GZ_NONE;

  00056	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  00059	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 120  :     state->level = Z_DEFAULT_COMPRESSION;

  00060	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  00063	c7 41 48 ff ff
	ff ff		 mov	 DWORD PTR [ecx+72], -1

; 121  :     state->strategy = Z_DEFAULT_STRATEGY;

  0006a	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  0006d	c7 42 4c 00 00
	00 00		 mov	 DWORD PTR [edx+76], 0

; 122  :     state->direct = 0;

  00074	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  00077	c7 40 2c 00 00
	00 00		 mov	 DWORD PTR [eax+44], 0
$LN33@gz_open:

; 123  :     while (*mode) {

  0007e	8b 4d 10	 mov	 ecx, DWORD PTR _mode$[ebp]
  00081	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00084	85 d2		 test	 edx, edx
  00086	0f 84 e2 00 00
	00		 je	 $LN32@gz_open

; 124  :         if (*mode >= '0' && *mode <= '9')

  0008c	8b 45 10	 mov	 eax, DWORD PTR _mode$[ebp]
  0008f	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00092	83 f9 30	 cmp	 ecx, 48			; 00000030H
  00095	7c 1f		 jl	 SHORT $LN31@gz_open
  00097	8b 55 10	 mov	 edx, DWORD PTR _mode$[ebp]
  0009a	0f be 02	 movsx	 eax, BYTE PTR [edx]
  0009d	83 f8 39	 cmp	 eax, 57			; 00000039H
  000a0	7f 14		 jg	 SHORT $LN31@gz_open

; 125  :             state->level = *mode - '0';

  000a2	8b 4d 10	 mov	 ecx, DWORD PTR _mode$[ebp]
  000a5	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  000a8	83 ea 30	 sub	 edx, 48			; 00000030H
  000ab	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  000ae	89 50 48	 mov	 DWORD PTR [eax+72], edx

; 126  :         else

  000b1	e9 aa 00 00 00	 jmp	 $LN30@gz_open
$LN31@gz_open:

; 127  :             switch (*mode) {

  000b6	8b 4d 10	 mov	 ecx, DWORD PTR _mode$[ebp]
  000b9	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  000bc	89 55 ec	 mov	 DWORD PTR tv85[ebp], edx
  000bf	8b 45 ec	 mov	 eax, DWORD PTR tv85[ebp]
  000c2	83 e8 2b	 sub	 eax, 43			; 0000002bH
  000c5	89 45 ec	 mov	 DWORD PTR tv85[ebp], eax
  000c8	83 7d ec 4d	 cmp	 DWORD PTR tv85[ebp], 77	; 0000004dH
  000cc	0f 87 8e 00 00
	00		 ja	 $LN30@gz_open
  000d2	8b 4d ec	 mov	 ecx, DWORD PTR tv85[ebp]
  000d5	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR $LN44@gz_open[ecx]
  000dc	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN45@gz_open[edx*4]
$LN27@gz_open:

; 128  :             case 'r':
; 129  :                 state->mode = GZ_READ;

  000e3	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  000e6	c7 40 10 4f 1c
	00 00		 mov	 DWORD PTR [eax+16], 7247 ; 00001c4fH

; 130  :                 break;

  000ed	eb 71		 jmp	 SHORT $LN30@gz_open
$LN26@gz_open:

; 131  : #ifndef NO_GZCOMPRESS
; 132  :             case 'w':
; 133  :                 state->mode = GZ_WRITE;

  000ef	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  000f2	c7 41 10 b1 79
	00 00		 mov	 DWORD PTR [ecx+16], 31153 ; 000079b1H

; 134  :                 break;

  000f9	eb 65		 jmp	 SHORT $LN30@gz_open
$LN25@gz_open:

; 135  :             case 'a':
; 136  :                 state->mode = GZ_APPEND;

  000fb	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  000fe	c7 42 10 01 00
	00 00		 mov	 DWORD PTR [edx+16], 1

; 137  :                 break;

  00105	eb 59		 jmp	 SHORT $LN30@gz_open
$LN24@gz_open:

; 138  : #endif
; 139  :             case '+':       /* can't read and write at the same time */
; 140  :                 free(state);

  00107	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  0010a	50		 push	 eax
  0010b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00111	83 c4 04	 add	 esp, 4

; 141  :                 return NULL;

  00114	33 c0		 xor	 eax, eax
  00116	e9 aa 02 00 00	 jmp	 $LN36@gz_open

; 142  :             case 'b':       /* ignore -- will request binary anyway */
; 143  :                 break;

  0011b	eb 43		 jmp	 SHORT $LN30@gz_open
$LN22@gz_open:

; 144  : #ifdef O_CLOEXEC
; 145  :             case 'e':
; 146  :                 cloexec = 1;
; 147  :                 break;
; 148  : #endif
; 149  : #ifdef O_EXCL
; 150  :             case 'x':
; 151  :                 exclusive = 1;

  0011d	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _exclusive$[ebp], 1

; 152  :                 break;

  00124	eb 3a		 jmp	 SHORT $LN30@gz_open
$LN21@gz_open:

; 153  : #endif
; 154  :             case 'f':
; 155  :                 state->strategy = Z_FILTERED;

  00126	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  00129	c7 41 4c 01 00
	00 00		 mov	 DWORD PTR [ecx+76], 1

; 156  :                 break;

  00130	eb 2e		 jmp	 SHORT $LN30@gz_open
$LN20@gz_open:

; 157  :             case 'h':
; 158  :                 state->strategy = Z_HUFFMAN_ONLY;

  00132	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  00135	c7 42 4c 02 00
	00 00		 mov	 DWORD PTR [edx+76], 2

; 159  :                 break;

  0013c	eb 22		 jmp	 SHORT $LN30@gz_open
$LN19@gz_open:

; 160  :             case 'R':
; 161  :                 state->strategy = Z_RLE;

  0013e	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  00141	c7 40 4c 03 00
	00 00		 mov	 DWORD PTR [eax+76], 3

; 162  :                 break;

  00148	eb 16		 jmp	 SHORT $LN30@gz_open
$LN18@gz_open:

; 163  :             case 'F':
; 164  :                 state->strategy = Z_FIXED;

  0014a	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  0014d	c7 41 4c 04 00
	00 00		 mov	 DWORD PTR [ecx+76], 4

; 165  :                 break;

  00154	eb 0a		 jmp	 SHORT $LN30@gz_open
$LN17@gz_open:

; 166  :             case 'T':
; 167  :                 state->direct = 1;

  00156	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  00159	c7 42 2c 01 00
	00 00		 mov	 DWORD PTR [edx+44], 1
$LN30@gz_open:

; 168  :                 break;
; 169  :             default:        /* could consider as an error, but just ignore */
; 170  :                 ;
; 171  :             }
; 172  :         mode++;

  00160	8b 45 10	 mov	 eax, DWORD PTR _mode$[ebp]
  00163	83 c0 01	 add	 eax, 1
  00166	89 45 10	 mov	 DWORD PTR _mode$[ebp], eax

; 173  :     }

  00169	e9 10 ff ff ff	 jmp	 $LN33@gz_open
$LN32@gz_open:

; 174  : 
; 175  :     /* must provide an "r", "w", or "a" */
; 176  :     if (state->mode == GZ_NONE) {

  0016e	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  00171	83 79 10 00	 cmp	 DWORD PTR [ecx+16], 0
  00175	75 14		 jne	 SHORT $LN15@gz_open

; 177  :         free(state);

  00177	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  0017a	52		 push	 edx
  0017b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00181	83 c4 04	 add	 esp, 4

; 178  :         return NULL;

  00184	33 c0		 xor	 eax, eax
  00186	e9 3a 02 00 00	 jmp	 $LN36@gz_open
$LN15@gz_open:

; 179  :     }
; 180  : 
; 181  :     /* can't force transparent read */
; 182  :     if (state->mode == GZ_READ) {

  0018b	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  0018e	81 78 10 4f 1c
	00 00		 cmp	 DWORD PTR [eax+16], 7247 ; 00001c4fH
  00195	75 27		 jne	 SHORT $LN14@gz_open

; 183  :         if (state->direct) {

  00197	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  0019a	83 79 2c 00	 cmp	 DWORD PTR [ecx+44], 0
  0019e	74 14		 je	 SHORT $LN13@gz_open

; 184  :             free(state);

  001a0	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  001a3	52		 push	 edx
  001a4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  001aa	83 c4 04	 add	 esp, 4

; 185  :             return NULL;

  001ad	33 c0		 xor	 eax, eax
  001af	e9 11 02 00 00	 jmp	 $LN36@gz_open
$LN13@gz_open:

; 186  :         }
; 187  :         state->direct = 1;      /* for empty file */

  001b4	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  001b7	c7 40 2c 01 00
	00 00		 mov	 DWORD PTR [eax+44], 1
$LN14@gz_open:

; 188  :     }
; 189  : 
; 190  :     /* save the path name for error messages */
; 191  : #ifdef _WIN32
; 192  :     if (fd == -2) {

  001be	83 7d 0c fe	 cmp	 DWORD PTR _fd$[ebp], -2	; fffffffeH
  001c2	75 23		 jne	 SHORT $LN12@gz_open

; 193  :         len = wcstombs(NULL, path, 0);

  001c4	6a 00		 push	 0
  001c6	8b 4d 08	 mov	 ecx, DWORD PTR _path$[ebp]
  001c9	51		 push	 ecx
  001ca	6a 00		 push	 0
  001cc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wcstombs
  001d2	83 c4 0c	 add	 esp, 12			; 0000000cH
  001d5	89 45 f8	 mov	 DWORD PTR _len$[ebp], eax

; 194  :         if (len == (size_t)-1)

  001d8	83 7d f8 ff	 cmp	 DWORD PTR _len$[ebp], -1
  001dc	75 07		 jne	 SHORT $LN11@gz_open

; 195  :             len = 0;

  001de	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _len$[ebp], 0
$LN11@gz_open:

; 196  :     }
; 197  :     else

  001e5	eb 0f		 jmp	 SHORT $LN10@gz_open
$LN12@gz_open:

; 198  : #endif
; 199  :         len = strlen((const char *)path);

  001e7	8b 55 08	 mov	 edx, DWORD PTR _path$[ebp]
  001ea	52		 push	 edx
  001eb	e8 00 00 00 00	 call	 _strlen
  001f0	83 c4 04	 add	 esp, 4
  001f3	89 45 f8	 mov	 DWORD PTR _len$[ebp], eax
$LN10@gz_open:

; 200  :     state->path = (char *)malloc(len + 1);

  001f6	8b 45 f8	 mov	 eax, DWORD PTR _len$[ebp]
  001f9	83 c0 01	 add	 eax, 1
  001fc	50		 push	 eax
  001fd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00203	83 c4 04	 add	 esp, 4
  00206	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  00209	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 201  :     if (state->path == NULL) {

  0020c	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  0020f	83 7a 18 00	 cmp	 DWORD PTR [edx+24], 0
  00213	75 14		 jne	 SHORT $LN9@gz_open

; 202  :         free(state);

  00215	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  00218	50		 push	 eax
  00219	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0021f	83 c4 04	 add	 esp, 4

; 203  :         return NULL;

  00222	33 c0		 xor	 eax, eax
  00224	e9 9c 01 00 00	 jmp	 $LN36@gz_open
$LN9@gz_open:

; 204  :     }
; 205  : #ifdef _WIN32
; 206  :     if (fd == -2)

  00229	83 7d 0c fe	 cmp	 DWORD PTR _fd$[ebp], -2	; fffffffeH
  0022d	75 2e		 jne	 SHORT $LN8@gz_open

; 207  :         if (len)

  0022f	83 7d f8 00	 cmp	 DWORD PTR _len$[ebp], 0
  00233	74 1d		 je	 SHORT $LN7@gz_open

; 208  :             wcstombs(state->path, path, len + 1);

  00235	8b 4d f8	 mov	 ecx, DWORD PTR _len$[ebp]
  00238	83 c1 01	 add	 ecx, 1
  0023b	51		 push	 ecx
  0023c	8b 55 08	 mov	 edx, DWORD PTR _path$[ebp]
  0023f	52		 push	 edx
  00240	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  00243	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00246	51		 push	 ecx
  00247	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wcstombs
  0024d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 209  :         else

  00250	eb 09		 jmp	 SHORT $LN6@gz_open
$LN7@gz_open:

; 210  :             *(state->path) = 0;

  00252	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  00255	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00258	c6 00 00	 mov	 BYTE PTR [eax], 0
$LN6@gz_open:

; 211  :     else

  0025b	eb 20		 jmp	 SHORT $LN5@gz_open
$LN8@gz_open:

; 212  : #endif
; 213  : #if !defined(NO_snprintf) && !defined(NO_vsnprintf)
; 214  :         snprintf(state->path, len + 1, "%s", (const char *)path);

  0025d	8b 4d 08	 mov	 ecx, DWORD PTR _path$[ebp]
  00260	51		 push	 ecx
  00261	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  00266	8b 55 f8	 mov	 edx, DWORD PTR _len$[ebp]
  00269	83 c2 01	 add	 edx, 1
  0026c	52		 push	 edx
  0026d	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  00270	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00273	51		 push	 ecx
  00274	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___snprintf
  0027a	83 c4 10	 add	 esp, 16			; 00000010H
$LN5@gz_open:

; 215  : #else
; 216  :         strcpy(state->path, path);
; 217  : #endif
; 218  : 
; 219  :     /* compute the flags for open() */
; 220  :     oflag =
; 221  : #ifdef O_LARGEFILE
; 222  :         O_LARGEFILE |
; 223  : #endif
; 224  : #ifdef O_BINARY
; 225  :         O_BINARY |
; 226  : #endif
; 227  : #ifdef O_CLOEXEC
; 228  :         (cloexec ? O_CLOEXEC : 0) |
; 229  : #endif
; 230  :         (state->mode == GZ_READ ?
; 231  :          O_RDONLY :
; 232  :          (O_WRONLY | O_CREAT |
; 233  : #ifdef O_EXCL
; 234  :           (exclusive ? O_EXCL : 0) |
; 235  : #endif
; 236  :           (state->mode == GZ_WRITE ?
; 237  :            O_TRUNC :
; 238  :            O_APPEND)));

  0027d	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  00280	81 7a 10 4f 1c
	00 00		 cmp	 DWORD PTR [edx+16], 7247 ; 00001c4fH
  00287	75 09		 jne	 SHORT $LN38@gz_open
  00289	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR tv178[ebp], 0
  00290	eb 32		 jmp	 SHORT $LN39@gz_open
$LN38@gz_open:
  00292	8b 45 fc	 mov	 eax, DWORD PTR _exclusive$[ebp]
  00295	f7 d8		 neg	 eax
  00297	1b c0		 sbb	 eax, eax
  00299	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  0029e	0d 01 01 00 00	 or	 eax, 257		; 00000101H
  002a3	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  002a6	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  002a9	81 ea b1 79 00
	00		 sub	 edx, 31153		; 000079b1H
  002af	f7 da		 neg	 edx
  002b1	1b d2		 sbb	 edx, edx
  002b3	81 e2 08 fe ff
	ff		 and	 edx, -504		; fffffe08H
  002b9	81 c2 00 02 00
	00		 add	 edx, 512		; 00000200H
  002bf	0b c2		 or	 eax, edx
  002c1	89 45 e8	 mov	 DWORD PTR tv178[ebp], eax
$LN39@gz_open:
  002c4	8b 45 e8	 mov	 eax, DWORD PTR tv178[ebp]
  002c7	0d 00 80 00 00	 or	 eax, 32768		; 00008000H
  002cc	89 45 f4	 mov	 DWORD PTR _oflag$[ebp], eax

; 239  : 
; 240  :     /* open the file with the appropriate flags (or just use fd) */
; 241  :     state->fd = fd > -1 ? fd : (
; 242  : #ifdef _WIN32
; 243  :         fd == -2 ? _wopen(path, oflag, 0666) :
; 244  : #endif
; 245  :         open((const char *)path, oflag, 0666));

  002cf	83 7d 0c ff	 cmp	 DWORD PTR _fd$[ebp], -1
  002d3	7e 08		 jle	 SHORT $LN42@gz_open
  002d5	8b 4d 0c	 mov	 ecx, DWORD PTR _fd$[ebp]
  002d8	89 4d e4	 mov	 DWORD PTR tv192[ebp], ecx
  002db	eb 40		 jmp	 SHORT $LN43@gz_open
$LN42@gz_open:
  002dd	83 7d 0c fe	 cmp	 DWORD PTR _fd$[ebp], -2	; fffffffeH
  002e1	75 1b		 jne	 SHORT $LN40@gz_open
  002e3	68 b6 01 00 00	 push	 438			; 000001b6H
  002e8	8b 55 f4	 mov	 edx, DWORD PTR _oflag$[ebp]
  002eb	52		 push	 edx
  002ec	8b 45 08	 mov	 eax, DWORD PTR _path$[ebp]
  002ef	50		 push	 eax
  002f0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wopen
  002f6	83 c4 0c	 add	 esp, 12			; 0000000cH
  002f9	89 45 e0	 mov	 DWORD PTR tv191[ebp], eax
  002fc	eb 19		 jmp	 SHORT $LN41@gz_open
$LN40@gz_open:
  002fe	68 b6 01 00 00	 push	 438			; 000001b6H
  00303	8b 4d f4	 mov	 ecx, DWORD PTR _oflag$[ebp]
  00306	51		 push	 ecx
  00307	8b 55 08	 mov	 edx, DWORD PTR _path$[ebp]
  0030a	52		 push	 edx
  0030b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__open
  00311	83 c4 0c	 add	 esp, 12			; 0000000cH
  00314	89 45 e0	 mov	 DWORD PTR tv191[ebp], eax
$LN41@gz_open:
  00317	8b 45 e0	 mov	 eax, DWORD PTR tv191[ebp]
  0031a	89 45 e4	 mov	 DWORD PTR tv192[ebp], eax
$LN43@gz_open:
  0031d	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  00320	8b 55 e4	 mov	 edx, DWORD PTR tv192[ebp]
  00323	89 51 14	 mov	 DWORD PTR [ecx+20], edx

; 246  :     if (state->fd == -1) {

  00326	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  00329	83 78 14 ff	 cmp	 DWORD PTR [eax+20], -1
  0032d	75 21		 jne	 SHORT $LN4@gz_open

; 247  :         free(state->path);

  0032f	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  00332	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00335	52		 push	 edx
  00336	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0033c	83 c4 04	 add	 esp, 4

; 248  :         free(state);

  0033f	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  00342	50		 push	 eax
  00343	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00349	83 c4 04	 add	 esp, 4

; 249  :         return NULL;

  0034c	33 c0		 xor	 eax, eax
  0034e	eb 75		 jmp	 SHORT $LN36@gz_open
$LN4@gz_open:

; 250  :     }
; 251  :     if (state->mode == GZ_APPEND)

  00350	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  00353	83 79 10 01	 cmp	 DWORD PTR [ecx+16], 1
  00357	75 0a		 jne	 SHORT $LN3@gz_open

; 252  :         state->mode = GZ_WRITE;         /* simplify later checks */

  00359	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  0035c	c7 42 10 b1 79
	00 00		 mov	 DWORD PTR [edx+16], 31153 ; 000079b1H
$LN3@gz_open:

; 253  : 
; 254  :     /* save the current position for rewinding (only if reading) */
; 255  :     if (state->mode == GZ_READ) {

  00363	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  00366	81 78 10 4f 1c
	00 00		 cmp	 DWORD PTR [eax+16], 7247 ; 00001c4fH
  0036d	75 47		 jne	 SHORT $LN2@gz_open

; 256  :         state->start = LSEEK(state->fd, 0, SEEK_CUR);

  0036f	6a 01		 push	 1
  00371	6a 00		 push	 0
  00373	6a 00		 push	 0
  00375	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  00378	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0037b	52		 push	 edx
  0037c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___lseeki64
  00382	83 c4 10	 add	 esp, 16			; 00000010H
  00385	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  00388	89 41 38	 mov	 DWORD PTR [ecx+56], eax
  0038b	89 51 3c	 mov	 DWORD PTR [ecx+60], edx

; 257  :         if (state->start == -1) state->start = 0;

  0038e	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  00391	89 55 dc	 mov	 DWORD PTR tv311[ebp], edx
  00394	8b 45 dc	 mov	 eax, DWORD PTR tv311[ebp]
  00397	8b 4d dc	 mov	 ecx, DWORD PTR tv311[ebp]
  0039a	8b 50 38	 mov	 edx, DWORD PTR [eax+56]
  0039d	23 51 3c	 and	 edx, DWORD PTR [ecx+60]
  003a0	83 fa ff	 cmp	 edx, -1
  003a3	75 11		 jne	 SHORT $LN2@gz_open
  003a5	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  003a8	c7 40 38 00 00
	00 00		 mov	 DWORD PTR [eax+56], 0
  003af	c7 40 3c 00 00
	00 00		 mov	 DWORD PTR [eax+60], 0
$LN2@gz_open:

; 258  :     }
; 259  : 
; 260  :     /* initialize stream */
; 261  :     gz_reset(state);

  003b6	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  003b9	51		 push	 ecx
  003ba	e8 00 00 00 00	 call	 _gz_reset
  003bf	83 c4 04	 add	 esp, 4

; 262  : 
; 263  :     /* return stream */
; 264  :     return (gzFile)state;

  003c2	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
$LN36@gz_open:

; 265  : }

  003c5	8b e5		 mov	 esp, ebp
  003c7	5d		 pop	 ebp
  003c8	c3		 ret	 0
  003c9	8d 49 00	 npad	 3
$LN45@gz_open:
  003cc	00 00 00 00	 DD	 $LN24@gz_open
  003d0	00 00 00 00	 DD	 $LN18@gz_open
  003d4	00 00 00 00	 DD	 $LN19@gz_open
  003d8	00 00 00 00	 DD	 $LN17@gz_open
  003dc	00 00 00 00	 DD	 $LN25@gz_open
  003e0	00 00 00 00	 DD	 $LN21@gz_open
  003e4	00 00 00 00	 DD	 $LN20@gz_open
  003e8	00 00 00 00	 DD	 $LN27@gz_open
  003ec	00 00 00 00	 DD	 $LN26@gz_open
  003f0	00 00 00 00	 DD	 $LN22@gz_open
  003f4	00 00 00 00	 DD	 $LN30@gz_open
$LN44@gz_open:
  003f8	00		 DB	 0
  003f9	0a		 DB	 10			; 0000000aH
  003fa	0a		 DB	 10			; 0000000aH
  003fb	0a		 DB	 10			; 0000000aH
  003fc	0a		 DB	 10			; 0000000aH
  003fd	0a		 DB	 10			; 0000000aH
  003fe	0a		 DB	 10			; 0000000aH
  003ff	0a		 DB	 10			; 0000000aH
  00400	0a		 DB	 10			; 0000000aH
  00401	0a		 DB	 10			; 0000000aH
  00402	0a		 DB	 10			; 0000000aH
  00403	0a		 DB	 10			; 0000000aH
  00404	0a		 DB	 10			; 0000000aH
  00405	0a		 DB	 10			; 0000000aH
  00406	0a		 DB	 10			; 0000000aH
  00407	0a		 DB	 10			; 0000000aH
  00408	0a		 DB	 10			; 0000000aH
  00409	0a		 DB	 10			; 0000000aH
  0040a	0a		 DB	 10			; 0000000aH
  0040b	0a		 DB	 10			; 0000000aH
  0040c	0a		 DB	 10			; 0000000aH
  0040d	0a		 DB	 10			; 0000000aH
  0040e	0a		 DB	 10			; 0000000aH
  0040f	0a		 DB	 10			; 0000000aH
  00410	0a		 DB	 10			; 0000000aH
  00411	0a		 DB	 10			; 0000000aH
  00412	0a		 DB	 10			; 0000000aH
  00413	01		 DB	 1
  00414	0a		 DB	 10			; 0000000aH
  00415	0a		 DB	 10			; 0000000aH
  00416	0a		 DB	 10			; 0000000aH
  00417	0a		 DB	 10			; 0000000aH
  00418	0a		 DB	 10			; 0000000aH
  00419	0a		 DB	 10			; 0000000aH
  0041a	0a		 DB	 10			; 0000000aH
  0041b	0a		 DB	 10			; 0000000aH
  0041c	0a		 DB	 10			; 0000000aH
  0041d	0a		 DB	 10			; 0000000aH
  0041e	0a		 DB	 10			; 0000000aH
  0041f	02		 DB	 2
  00420	0a		 DB	 10			; 0000000aH
  00421	03		 DB	 3
  00422	0a		 DB	 10			; 0000000aH
  00423	0a		 DB	 10			; 0000000aH
  00424	0a		 DB	 10			; 0000000aH
  00425	0a		 DB	 10			; 0000000aH
  00426	0a		 DB	 10			; 0000000aH
  00427	0a		 DB	 10			; 0000000aH
  00428	0a		 DB	 10			; 0000000aH
  00429	0a		 DB	 10			; 0000000aH
  0042a	0a		 DB	 10			; 0000000aH
  0042b	0a		 DB	 10			; 0000000aH
  0042c	0a		 DB	 10			; 0000000aH
  0042d	0a		 DB	 10			; 0000000aH
  0042e	04		 DB	 4
  0042f	0a		 DB	 10			; 0000000aH
  00430	0a		 DB	 10			; 0000000aH
  00431	0a		 DB	 10			; 0000000aH
  00432	0a		 DB	 10			; 0000000aH
  00433	05		 DB	 5
  00434	0a		 DB	 10			; 0000000aH
  00435	06		 DB	 6
  00436	0a		 DB	 10			; 0000000aH
  00437	0a		 DB	 10			; 0000000aH
  00438	0a		 DB	 10			; 0000000aH
  00439	0a		 DB	 10			; 0000000aH
  0043a	0a		 DB	 10			; 0000000aH
  0043b	0a		 DB	 10			; 0000000aH
  0043c	0a		 DB	 10			; 0000000aH
  0043d	0a		 DB	 10			; 0000000aH
  0043e	0a		 DB	 10			; 0000000aH
  0043f	07		 DB	 7
  00440	0a		 DB	 10			; 0000000aH
  00441	0a		 DB	 10			; 0000000aH
  00442	0a		 DB	 10			; 0000000aH
  00443	0a		 DB	 10			; 0000000aH
  00444	08		 DB	 8
  00445	09		 DB	 9
_gz_open ENDP
PUBLIC	_gzseek64@16
; Function compile flags: /Odtp
;	COMDAT _gzseek64@16
_TEXT	SEGMENT
tv156 = -40						; size = 4
tv282 = -36						; size = 8
tv211 = -28						; size = 8
_state$ = -20						; size = 4
_ret$ = -16						; size = 8
_n$ = -4						; size = 4
_file$ = 8						; size = 4
_offset$ = 12						; size = 8
_whence$ = 20						; size = 4
_gzseek64@16 PROC					; COMDAT

; 366  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H

; 367  :     unsigned n;
; 368  :     z_off64_t ret;
; 369  :     gz_statep state;
; 370  : 
; 371  :     /* get internal structure and check integrity */
; 372  :     if (file == NULL)

  00006	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  0000a	75 0b		 jne	 SHORT $LN15@gzseek64

; 373  :         return -1;

  0000c	83 c8 ff	 or	 eax, -1
  0000f	83 ca ff	 or	 edx, -1
  00012	e9 bd 02 00 00	 jmp	 $LN16@gzseek64
$LN15@gzseek64:

; 374  :     state = (gz_statep)file;

  00017	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  0001a	89 45 ec	 mov	 DWORD PTR _state$[ebp], eax

; 375  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  0001d	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  00020	81 79 10 4f 1c
	00 00		 cmp	 DWORD PTR [ecx+16], 7247 ; 00001c4fH
  00027	74 17		 je	 SHORT $LN14@gzseek64
  00029	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  0002c	81 7a 10 b1 79
	00 00		 cmp	 DWORD PTR [edx+16], 31153 ; 000079b1H
  00033	74 0b		 je	 SHORT $LN14@gzseek64

; 376  :         return -1;

  00035	83 c8 ff	 or	 eax, -1
  00038	83 ca ff	 or	 edx, -1
  0003b	e9 94 02 00 00	 jmp	 $LN16@gzseek64
$LN14@gzseek64:

; 377  : 
; 378  :     /* check that there's no error */
; 379  :     if (state->err != Z_OK && state->err != Z_BUF_ERROR)

  00040	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  00043	83 78 5c 00	 cmp	 DWORD PTR [eax+92], 0
  00047	74 14		 je	 SHORT $LN13@gzseek64
  00049	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  0004c	83 79 5c fb	 cmp	 DWORD PTR [ecx+92], -5	; fffffffbH
  00050	74 0b		 je	 SHORT $LN13@gzseek64

; 380  :         return -1;

  00052	83 c8 ff	 or	 eax, -1
  00055	83 ca ff	 or	 edx, -1
  00058	e9 77 02 00 00	 jmp	 $LN16@gzseek64
$LN13@gzseek64:

; 381  : 
; 382  :     /* can only seek from start or relative to current position */
; 383  :     if (whence != SEEK_SET && whence != SEEK_CUR)

  0005d	83 7d 14 00	 cmp	 DWORD PTR _whence$[ebp], 0
  00061	74 11		 je	 SHORT $LN12@gzseek64
  00063	83 7d 14 01	 cmp	 DWORD PTR _whence$[ebp], 1
  00067	74 0b		 je	 SHORT $LN12@gzseek64

; 384  :         return -1;

  00069	83 c8 ff	 or	 eax, -1
  0006c	83 ca ff	 or	 edx, -1
  0006f	e9 60 02 00 00	 jmp	 $LN16@gzseek64
$LN12@gzseek64:

; 385  : 
; 386  :     /* normalize offset to a SEEK_CUR specification */
; 387  :     if (whence == SEEK_SET)

  00074	83 7d 14 00	 cmp	 DWORD PTR _whence$[ebp], 0
  00078	75 17		 jne	 SHORT $LN11@gzseek64

; 388  :         offset -= state->x.pos;

  0007a	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  0007d	8b 45 0c	 mov	 eax, DWORD PTR _offset$[ebp]
  00080	2b 42 08	 sub	 eax, DWORD PTR [edx+8]
  00083	8b 4d 10	 mov	 ecx, DWORD PTR _offset$[ebp+4]
  00086	1b 4a 0c	 sbb	 ecx, DWORD PTR [edx+12]
  00089	89 45 0c	 mov	 DWORD PTR _offset$[ebp], eax
  0008c	89 4d 10	 mov	 DWORD PTR _offset$[ebp+4], ecx
  0008f	eb 1e		 jmp	 SHORT $LN10@gzseek64
$LN11@gzseek64:

; 389  :     else if (state->seek)

  00091	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  00094	83 7a 58 00	 cmp	 DWORD PTR [edx+88], 0
  00098	74 15		 je	 SHORT $LN10@gzseek64

; 390  :         offset += state->skip;

  0009a	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  0009d	8b 4d 0c	 mov	 ecx, DWORD PTR _offset$[ebp]
  000a0	03 48 50	 add	 ecx, DWORD PTR [eax+80]
  000a3	8b 55 10	 mov	 edx, DWORD PTR _offset$[ebp+4]
  000a6	13 50 54	 adc	 edx, DWORD PTR [eax+84]
  000a9	89 4d 0c	 mov	 DWORD PTR _offset$[ebp], ecx
  000ac	89 55 10	 mov	 DWORD PTR _offset$[ebp+4], edx
$LN10@gzseek64:

; 391  :     state->seek = 0;

  000af	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  000b2	c7 40 58 00 00
	00 00		 mov	 DWORD PTR [eax+88], 0

; 392  : 
; 393  :     /* if within raw area while reading, just go there */
; 394  :     if (state->mode == GZ_READ && state->how == COPY &&
; 395  :             state->x.pos + offset >= 0) {

  000b9	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  000bc	81 79 10 4f 1c
	00 00		 cmp	 DWORD PTR [ecx+16], 7247 ; 00001c4fH
  000c3	0f 85 dc 00 00
	00		 jne	 $LN8@gzseek64
  000c9	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  000cc	83 7a 30 01	 cmp	 DWORD PTR [edx+48], 1
  000d0	0f 85 cf 00 00
	00		 jne	 $LN8@gzseek64
  000d6	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  000d9	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000dc	03 4d 0c	 add	 ecx, DWORD PTR _offset$[ebp]
  000df	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  000e2	13 55 10	 adc	 edx, DWORD PTR _offset$[ebp+4]
  000e5	89 4d e4	 mov	 DWORD PTR tv211[ebp], ecx
  000e8	89 55 e8	 mov	 DWORD PTR tv211[ebp+4], edx
  000eb	0f 88 b4 00 00
	00		 js	 $LN8@gzseek64
  000f1	7f 0a		 jg	 SHORT $LN20@gzseek64
  000f3	83 7d e4 00	 cmp	 DWORD PTR tv211[ebp], 0
  000f7	0f 82 a8 00 00
	00		 jb	 $LN8@gzseek64
$LN20@gzseek64:

; 396  :         ret = LSEEK(state->fd, offset - state->x.have, SEEK_CUR);

  000fd	6a 01		 push	 1
  000ff	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  00102	8b 08		 mov	 ecx, DWORD PTR [eax]
  00104	33 d2		 xor	 edx, edx
  00106	8b 45 0c	 mov	 eax, DWORD PTR _offset$[ebp]
  00109	2b c1		 sub	 eax, ecx
  0010b	8b 4d 10	 mov	 ecx, DWORD PTR _offset$[ebp+4]
  0010e	1b ca		 sbb	 ecx, edx
  00110	51		 push	 ecx
  00111	50		 push	 eax
  00112	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  00115	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00118	50		 push	 eax
  00119	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___lseeki64
  0011f	83 c4 10	 add	 esp, 16			; 00000010H
  00122	89 45 f0	 mov	 DWORD PTR _ret$[ebp], eax
  00125	89 55 f4	 mov	 DWORD PTR _ret$[ebp+4], edx

; 397  :         if (ret == -1)

  00128	8b 4d f0	 mov	 ecx, DWORD PTR _ret$[ebp]
  0012b	23 4d f4	 and	 ecx, DWORD PTR _ret$[ebp+4]
  0012e	83 f9 ff	 cmp	 ecx, -1
  00131	75 0b		 jne	 SHORT $LN7@gzseek64

; 398  :             return -1;

  00133	83 c8 ff	 or	 eax, -1
  00136	83 ca ff	 or	 edx, -1
  00139	e9 96 01 00 00	 jmp	 $LN16@gzseek64
$LN7@gzseek64:

; 399  :         state->x.have = 0;

  0013e	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  00141	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 400  :         state->eof = 0;

  00147	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  0014a	c7 40 40 00 00
	00 00		 mov	 DWORD PTR [eax+64], 0

; 401  :         state->past = 0;

  00151	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  00154	c7 41 44 00 00
	00 00		 mov	 DWORD PTR [ecx+68], 0

; 402  :         state->seek = 0;

  0015b	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  0015e	c7 42 58 00 00
	00 00		 mov	 DWORD PTR [edx+88], 0

; 403  :         gz_error(state, Z_OK, NULL);

  00165	6a 00		 push	 0
  00167	6a 00		 push	 0
  00169	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  0016c	50		 push	 eax
  0016d	e8 00 00 00 00	 call	 _gz_error
  00172	83 c4 0c	 add	 esp, 12			; 0000000cH

; 404  :         state->strm.avail_in = 0;

  00175	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  00178	c7 41 68 00 00
	00 00		 mov	 DWORD PTR [ecx+104], 0

; 405  :         state->x.pos += offset;

  0017f	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  00182	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00185	03 45 0c	 add	 eax, DWORD PTR _offset$[ebp]
  00188	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  0018b	13 4d 10	 adc	 ecx, DWORD PTR _offset$[ebp+4]
  0018e	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  00191	89 42 08	 mov	 DWORD PTR [edx+8], eax
  00194	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 406  :         return state->x.pos;

  00197	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  0019a	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0019d	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  001a0	e9 2f 01 00 00	 jmp	 $LN16@gzseek64
$LN8@gzseek64:

; 407  :     }
; 408  : 
; 409  :     /* calculate skip amount, rewinding if needed for back seek when reading */
; 410  :     if (offset < 0) {

  001a5	83 7d 10 00	 cmp	 DWORD PTR _offset$[ebp+4], 0
  001a9	7f 66		 jg	 SHORT $LN6@gzseek64
  001ab	7c 06		 jl	 SHORT $LN21@gzseek64
  001ad	83 7d 0c 00	 cmp	 DWORD PTR _offset$[ebp], 0
  001b1	73 5e		 jae	 SHORT $LN6@gzseek64
$LN21@gzseek64:

; 411  :         if (state->mode != GZ_READ)         /* writing -- can't go backwards */

  001b3	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  001b6	81 7a 10 4f 1c
	00 00		 cmp	 DWORD PTR [edx+16], 7247 ; 00001c4fH
  001bd	74 0b		 je	 SHORT $LN5@gzseek64

; 412  :             return -1;

  001bf	83 c8 ff	 or	 eax, -1
  001c2	83 ca ff	 or	 edx, -1
  001c5	e9 0a 01 00 00	 jmp	 $LN16@gzseek64
$LN5@gzseek64:

; 413  :         offset += state->x.pos;

  001ca	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  001cd	8b 4d 0c	 mov	 ecx, DWORD PTR _offset$[ebp]
  001d0	03 48 08	 add	 ecx, DWORD PTR [eax+8]
  001d3	8b 55 10	 mov	 edx, DWORD PTR _offset$[ebp+4]
  001d6	13 50 0c	 adc	 edx, DWORD PTR [eax+12]
  001d9	89 4d 0c	 mov	 DWORD PTR _offset$[ebp], ecx
  001dc	89 55 10	 mov	 DWORD PTR _offset$[ebp+4], edx

; 414  :         if (offset < 0)                     /* before start of file! */

  001df	83 7d 10 00	 cmp	 DWORD PTR _offset$[ebp+4], 0
  001e3	7f 13		 jg	 SHORT $LN4@gzseek64
  001e5	7c 06		 jl	 SHORT $LN22@gzseek64
  001e7	83 7d 0c 00	 cmp	 DWORD PTR _offset$[ebp], 0
  001eb	73 0b		 jae	 SHORT $LN4@gzseek64
$LN22@gzseek64:

; 415  :             return -1;

  001ed	83 c8 ff	 or	 eax, -1
  001f0	83 ca ff	 or	 edx, -1
  001f3	e9 dc 00 00 00	 jmp	 $LN16@gzseek64
$LN4@gzseek64:

; 416  :         if (gzrewind(file) == -1)           /* rewind, then skip to offset */

  001f8	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  001fb	50		 push	 eax
  001fc	e8 00 00 00 00	 call	 _gzrewind@4
  00201	83 f8 ff	 cmp	 eax, -1
  00204	75 0b		 jne	 SHORT $LN6@gzseek64

; 417  :             return -1;

  00206	83 c8 ff	 or	 eax, -1
  00209	83 ca ff	 or	 edx, -1
  0020c	e9 c3 00 00 00	 jmp	 $LN16@gzseek64
$LN6@gzseek64:

; 418  :     }
; 419  : 
; 420  :     /* if reading, skip what's in output buffer (one less gzgetc() check) */
; 421  :     if (state->mode == GZ_READ) {

  00211	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  00214	81 79 10 4f 1c
	00 00		 cmp	 DWORD PTR [ecx+16], 7247 ; 00001c4fH
  0021b	0f 85 83 00 00
	00		 jne	 $LN2@gzseek64

; 422  :         n = GT_OFF(state->x.have) || (z_off64_t)state->x.have > offset ?
; 423  :             (unsigned)offset : state->x.have;

  00221	33 d2		 xor	 edx, edx
  00223	75 29		 jne	 SHORT $LN18@gzseek64
  00225	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  00228	8b 08		 mov	 ecx, DWORD PTR [eax]
  0022a	33 d2		 xor	 edx, edx
  0022c	89 4d dc	 mov	 DWORD PTR tv282[ebp], ecx
  0022f	89 55 e0	 mov	 DWORD PTR tv282[ebp+4], edx
  00232	8b 45 e0	 mov	 eax, DWORD PTR tv282[ebp+4]
  00235	3b 45 10	 cmp	 eax, DWORD PTR _offset$[ebp+4]
  00238	7f 14		 jg	 SHORT $LN18@gzseek64
  0023a	7c 08		 jl	 SHORT $LN23@gzseek64
  0023c	8b 4d dc	 mov	 ecx, DWORD PTR tv282[ebp]
  0023f	3b 4d 0c	 cmp	 ecx, DWORD PTR _offset$[ebp]
  00242	77 0a		 ja	 SHORT $LN18@gzseek64
$LN23@gzseek64:
  00244	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  00247	8b 02		 mov	 eax, DWORD PTR [edx]
  00249	89 45 d8	 mov	 DWORD PTR tv156[ebp], eax
  0024c	eb 06		 jmp	 SHORT $LN19@gzseek64
$LN18@gzseek64:
  0024e	8b 4d 0c	 mov	 ecx, DWORD PTR _offset$[ebp]
  00251	89 4d d8	 mov	 DWORD PTR tv156[ebp], ecx
$LN19@gzseek64:
  00254	8b 55 d8	 mov	 edx, DWORD PTR tv156[ebp]
  00257	89 55 fc	 mov	 DWORD PTR _n$[ebp], edx

; 424  :         state->x.have -= n;

  0025a	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  0025d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0025f	2b 4d fc	 sub	 ecx, DWORD PTR _n$[ebp]
  00262	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  00265	89 0a		 mov	 DWORD PTR [edx], ecx

; 425  :         state->x.next += n;

  00267	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  0026a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0026d	03 4d fc	 add	 ecx, DWORD PTR _n$[ebp]
  00270	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  00273	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 426  :         state->x.pos += n;

  00276	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  00279	33 c9		 xor	 ecx, ecx
  0027b	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  0027e	03 42 08	 add	 eax, DWORD PTR [edx+8]
  00281	8b 52 0c	 mov	 edx, DWORD PTR [edx+12]
  00284	13 d1		 adc	 edx, ecx
  00286	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  00289	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  0028c	89 51 0c	 mov	 DWORD PTR [ecx+12], edx

; 427  :         offset -= n;

  0028f	8b 55 fc	 mov	 edx, DWORD PTR _n$[ebp]
  00292	33 c0		 xor	 eax, eax
  00294	8b 4d 0c	 mov	 ecx, DWORD PTR _offset$[ebp]
  00297	2b ca		 sub	 ecx, edx
  00299	8b 55 10	 mov	 edx, DWORD PTR _offset$[ebp+4]
  0029c	1b d0		 sbb	 edx, eax
  0029e	89 4d 0c	 mov	 DWORD PTR _offset$[ebp], ecx
  002a1	89 55 10	 mov	 DWORD PTR _offset$[ebp+4], edx
$LN2@gzseek64:

; 428  :     }
; 429  : 
; 430  :     /* request skip (if not zero) */
; 431  :     if (offset) {

  002a4	8b 45 0c	 mov	 eax, DWORD PTR _offset$[ebp]
  002a7	0b 45 10	 or	 eax, DWORD PTR _offset$[ebp+4]
  002aa	74 19		 je	 SHORT $LN1@gzseek64

; 432  :         state->seek = 1;

  002ac	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  002af	c7 41 58 01 00
	00 00		 mov	 DWORD PTR [ecx+88], 1

; 433  :         state->skip = offset;

  002b6	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  002b9	8b 45 0c	 mov	 eax, DWORD PTR _offset$[ebp]
  002bc	89 42 50	 mov	 DWORD PTR [edx+80], eax
  002bf	8b 4d 10	 mov	 ecx, DWORD PTR _offset$[ebp+4]
  002c2	89 4a 54	 mov	 DWORD PTR [edx+84], ecx
$LN1@gzseek64:

; 434  :     }
; 435  :     return state->x.pos + offset;

  002c5	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  002c8	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  002cb	03 45 0c	 add	 eax, DWORD PTR _offset$[ebp]
  002ce	8b 52 0c	 mov	 edx, DWORD PTR [edx+12]
  002d1	13 55 10	 adc	 edx, DWORD PTR _offset$[ebp+4]
$LN16@gzseek64:

; 436  : }

  002d4	8b e5		 mov	 esp, ebp
  002d6	5d		 pop	 ebp
  002d7	c2 10 00	 ret	 16			; 00000010H
_gzseek64@16 ENDP
_TEXT	ENDS
PUBLIC	_gzopen_w@8
; Function compile flags: /Odtp
;	COMDAT _gzopen_w@8
_TEXT	SEGMENT
_path$ = 8						; size = 4
_mode$ = 12						; size = 4
_gzopen_w@8 PROC					; COMDAT

; 308  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 309  :     return gz_open(path, -2, mode);

  00003	8b 45 0c	 mov	 eax, DWORD PTR _mode$[ebp]
  00006	50		 push	 eax
  00007	6a fe		 push	 -2			; fffffffeH
  00009	8b 4d 08	 mov	 ecx, DWORD PTR _path$[ebp]
  0000c	51		 push	 ecx
  0000d	e8 00 00 00 00	 call	 _gz_open
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH

; 310  : }

  00015	5d		 pop	 ebp
  00016	c2 08 00	 ret	 8
_gzopen_w@8 ENDP
_TEXT	ENDS
PUBLIC	_gzdopen@8
; Function compile flags: /Odtp
;	COMDAT _gzdopen@8
_TEXT	SEGMENT
_path$ = -8						; size = 4
_gz$ = -4						; size = 4
_fd$ = 8						; size = 4
_mode$ = 12						; size = 4
_gzdopen@8 PROC						; COMDAT

; 287  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 288  :     char *path;         /* identifier for error messages */
; 289  :     gzFile gz;
; 290  : 
; 291  :     if (fd == -1 || (path = (char *)malloc(7 + 3 * sizeof(int))) == NULL)

  00006	83 7d 08 ff	 cmp	 DWORD PTR _fd$[ebp], -1
  0000a	74 14		 je	 SHORT $LN1@gzdopen
  0000c	6a 13		 push	 19			; 00000013H
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00014	83 c4 04	 add	 esp, 4
  00017	89 45 f8	 mov	 DWORD PTR _path$[ebp], eax
  0001a	83 7d f8 00	 cmp	 DWORD PTR _path$[ebp], 0
  0001e	75 04		 jne	 SHORT $LN2@gzdopen
$LN1@gzdopen:

; 292  :         return NULL;

  00020	33 c0		 xor	 eax, eax
  00022	eb 3f		 jmp	 SHORT $LN3@gzdopen
$LN2@gzdopen:

; 293  : #if !defined(NO_snprintf) && !defined(NO_vsnprintf)
; 294  :     snprintf(path, 7 + 3 * sizeof(int), "<fd:%d>", fd); /* for debugging */

  00024	8b 45 08	 mov	 eax, DWORD PTR _fd$[ebp]
  00027	50		 push	 eax
  00028	68 00 00 00 00	 push	 OFFSET ??_C@_07EBNKNFJN@?$DMfd?3?$CFd?$DO?$AA@
  0002d	6a 13		 push	 19			; 00000013H
  0002f	8b 4d f8	 mov	 ecx, DWORD PTR _path$[ebp]
  00032	51		 push	 ecx
  00033	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___snprintf
  00039	83 c4 10	 add	 esp, 16			; 00000010H

; 295  : #else
; 296  :     sprintf(path, "<fd:%d>", fd);   /* for debugging */
; 297  : #endif
; 298  :     gz = gz_open(path, fd, mode);

  0003c	8b 55 0c	 mov	 edx, DWORD PTR _mode$[ebp]
  0003f	52		 push	 edx
  00040	8b 45 08	 mov	 eax, DWORD PTR _fd$[ebp]
  00043	50		 push	 eax
  00044	8b 4d f8	 mov	 ecx, DWORD PTR _path$[ebp]
  00047	51		 push	 ecx
  00048	e8 00 00 00 00	 call	 _gz_open
  0004d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00050	89 45 fc	 mov	 DWORD PTR _gz$[ebp], eax

; 299  :     free(path);

  00053	8b 55 f8	 mov	 edx, DWORD PTR _path$[ebp]
  00056	52		 push	 edx
  00057	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0005d	83 c4 04	 add	 esp, 4

; 300  :     return gz;

  00060	8b 45 fc	 mov	 eax, DWORD PTR _gz$[ebp]
$LN3@gzdopen:

; 301  : }

  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c2 08 00	 ret	 8
_gzdopen@8 ENDP
_TEXT	ENDS
PUBLIC	_gzopen@8
; Function compile flags: /Odtp
;	COMDAT _gzopen@8
_TEXT	SEGMENT
_path$ = 8						; size = 4
_mode$ = 12						; size = 4
_gzopen@8 PROC						; COMDAT

; 271  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 272  :     return gz_open(path, -1, mode);

  00003	8b 45 0c	 mov	 eax, DWORD PTR _mode$[ebp]
  00006	50		 push	 eax
  00007	6a ff		 push	 -1
  00009	8b 4d 08	 mov	 ecx, DWORD PTR _path$[ebp]
  0000c	51		 push	 ecx
  0000d	e8 00 00 00 00	 call	 _gz_open
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH

; 273  : }

  00015	5d		 pop	 ebp
  00016	c2 08 00	 ret	 8
_gzopen@8 ENDP
PUBLIC	_gzseek@12
; Function compile flags: /Odtp
;	COMDAT _gzseek@12
_TEXT	SEGMENT
tv73 = -20						; size = 4
tv95 = -16						; size = 8
_ret$ = -8						; size = 8
_file$ = 8						; size = 4
_offset$ = 12						; size = 4
_whence$ = 16						; size = 4
_gzseek@12 PROC						; COMDAT

; 443  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 444  :     z_off64_t ret;
; 445  : 
; 446  :     ret = gzseek64(file, (z_off64_t)offset, whence);

  00006	8b 45 10	 mov	 eax, DWORD PTR _whence$[ebp]
  00009	50		 push	 eax
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _offset$[ebp]
  0000d	99		 cdq
  0000e	52		 push	 edx
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR _file$[ebp]
  00013	51		 push	 ecx
  00014	e8 00 00 00 00	 call	 _gzseek64@16
  00019	89 45 f8	 mov	 DWORD PTR _ret$[ebp], eax
  0001c	89 55 fc	 mov	 DWORD PTR _ret$[ebp+4], edx

; 447  :     return ret == (z_off_t)ret ? (z_off_t)ret : -1;

  0001f	8b 45 f8	 mov	 eax, DWORD PTR _ret$[ebp]
  00022	99		 cdq
  00023	89 45 f0	 mov	 DWORD PTR tv95[ebp], eax
  00026	89 55 f4	 mov	 DWORD PTR tv95[ebp+4], edx
  00029	8b 55 f8	 mov	 edx, DWORD PTR _ret$[ebp]
  0002c	3b 55 f0	 cmp	 edx, DWORD PTR tv95[ebp]
  0002f	75 10		 jne	 SHORT $LN3@gzseek
  00031	8b 45 fc	 mov	 eax, DWORD PTR _ret$[ebp+4]
  00034	3b 45 f4	 cmp	 eax, DWORD PTR tv95[ebp+4]
  00037	75 08		 jne	 SHORT $LN3@gzseek
  00039	8b 4d f8	 mov	 ecx, DWORD PTR _ret$[ebp]
  0003c	89 4d ec	 mov	 DWORD PTR tv73[ebp], ecx
  0003f	eb 07		 jmp	 SHORT $LN4@gzseek
$LN3@gzseek:
  00041	c7 45 ec ff ff
	ff ff		 mov	 DWORD PTR tv73[ebp], -1
$LN4@gzseek:
  00048	8b 45 ec	 mov	 eax, DWORD PTR tv73[ebp]

; 448  : }

  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c2 0c 00	 ret	 12			; 0000000cH
_gzseek@12 ENDP
END
